/* GANG Software
 * BASE/eval/Parser.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++

#include <stdlib.h>
#include <string.h>
#include <alloca.h>
#include "Parser.H"

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif

#if !defined(DISABLE_EVAL_NAMESPACE)
namespace eval {
#endif
// constructor
Parser::
Parser() : Lexer() {}

// destructor
Parser::
~Parser() {}

void
Parser::
parsex()
{
  int r = parse();
  if (r != 0)
  { throw base::Exception( "eval: parse error" ); }
}

void
Parser::
parse_nop( LvalStruct &a, LvalStruct const &x )
{
  DIE_IF( x._tag != LvalStruct::NODE );
  a = x;
}

void
Parser::
parse_number( LvalStruct &a, LvalStruct &x )
{
  DIE_IF( x._tag != LvalStruct::STRING );

  a._tag = LvalStruct::NODE;
  a._node = new EvalNode( TT_number, SY_nothing, x._string );

  x._tag = LvalStruct::NOTHING;
}

void
Parser::
parse_identifier( LvalStruct &a, LvalStruct &x )
{
  DIE_IF( x._tag != LvalStruct::STRING );

  a._tag = LvalStruct::NODE;
  a._node = new EvalNode( TT_identifier, SY_nothing, x._string );

  x._tag = LvalStruct::NOTHING;
}

void
Parser::
parse_unary_op( LvalStruct &a, tokens op, LvalStruct const &x )
{
  DIE_IF( x._tag != LvalStruct::NODE );

  a._tag = LvalStruct::NODE;

  op = tokens((int)op - ((int)SY_add - (int)SY_pos));

  a._node = new EvalNode( TT_unary_op, op, x._node, (EvalNode *)0);
}

void
Parser::
parse_binary_op( LvalStruct &a, tokens op, LvalStruct const &x,
                 LvalStruct const &y)
{
  DIE_IF( x._tag != LvalStruct::NODE );
  DIE_IF( y._tag != LvalStruct::NODE );

  a._tag = LvalStruct::NODE;
  a._node = new EvalNode( TT_binary_op, op, x._node, y._node );
}

void
Parser::
parse_unary_fn( LvalStruct &a, LvalStruct &f,
                LvalStruct const &x )
{
  DIE_IF( f._tag != LvalStruct::STRING );
  DIE_IF( x._tag != LvalStruct::NODE );

  a._tag = LvalStruct::NODE;
  a._node = new EvalNode( TT_unary_fn, SY_nothing, f._string,  x._node,
                      (EvalNode *)0);

  f._tag = LvalStruct::NOTHING;
}

void
Parser::
parse_binary_fn( LvalStruct &a, LvalStruct &f,
                 LvalStruct const &x,
                 LvalStruct const &y )
{
  DIE_IF( f._tag != LvalStruct::STRING );
  DIE_IF( x._tag != LvalStruct::NODE );

  a._tag = LvalStruct::NODE;
  a._node = new EvalNode( TT_binary_fn, SY_nothing, f._string, x._node, y._node );

  f._tag = LvalStruct::NOTHING;
}

void
Parser::
error( char const * /*message*/ )
{
  //  std::cerr << "eval parse error: " << message << std::endl;
}

Parser::
Parser( Parser const & )
{
  abort();
}

Parser &
Parser::
operator=( Parser const & )
{
  abort();
  return *this;
}

int const Parser::FINAL = 38;
int const Parser::NTBASE = 19;
int const Parser::LAST = 47;
int const Parser::EOF_ = 0;
int const Parser::EMPTY = -2;
int const Parser::FLAG = -32768;
int const Parser::TERROR = 1;
int const Parser::ERRCODE = 256;
int const Parser::INITDEPTH = 200;
size_t const Parser::MAXDEPTH = 10000;

Parser::UCHAR const Parser::translate[] =
{     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18
};

short const Parser::r1[] =
{     0,
    19,    19,    19,    20,    20,    20,    21,    21,    21,    21,
    22,    22,    22,    23,    23,    24,    24,    24,    24,    24
};

short const Parser::r2[] =
{     0,
     1,     2,     2,     1,     3,     3,     1,     3,     3,     2,
     1,     2,     2,     1,     3,     1,     1,     3,     4,     6
};

short const Parser::defact[] =
{     0,
     0,     1,    16,    17,     0,     0,     0,     0,     4,     7,
    11,    14,     3,     0,    12,    13,     0,     2,     0,     0,
     0,     0,    10,     0,     0,    18,     5,     6,     8,     9,
    15,    19,     0,     0,    20,     0,     0,     0
};

short const Parser::defgoto[] =
{    36,
     8,     9,    10,    11,    12
};

short const Parser::pact[] =
{    24,
    11,-32768,-32768,    -9,     0,     0,     0,    36,    30,-32768,
-32768,    -2,-32768,     0,-32768,-32768,    22,-32768,     0,     0,
     0,     0,-32768,     0,     7,-32768,    30,    30,-32768,-32768,
-32768,-32768,     0,     3,-32768,    38,    42,-32768
};

short const Parser::pgoto[] =
{-32768,
    -7,    27,    -4,    -6,-32768
};

short const Parser::table[] =
{    17,
    15,    16,    23,     3,     4,    14,    25,     5,     6,    24,
    19,    20,     7,    13,    19,    20,    29,    30,    35,    31,
    23,    23,    32,    33,     1,    34,     2,     3,     4,    19,
    20,     5,     6,     3,     4,    26,     7,    37,    18,    21,
    22,    38,     7,    19,    20,    27,    28
};

short const Parser::check[] =
{     7,
     5,     6,     9,     4,     5,    15,    14,     8,     9,    12,
     8,     9,    13,     3,     8,     9,    21,    22,    16,    24,
    27,    28,    16,    17,     1,    33,     3,     4,     5,     8,
     9,     8,     9,     4,     5,    14,    13,     0,     3,    10,
    11,     0,    13,     8,     9,    19,    20
};


int
Parser::
parse()
{
  int state;
  int n;
  short *ssp;
  LvalStruct *vsp;
  int errstatus;
  int char1 = 0;

  short ssa[INITDEPTH];
  LvalStruct vsa[INITDEPTH];

  short *ss = ssa;
  LvalStruct *vs = vsa;

  size_t stacksize = INITDEPTH;

  int char_;
  LvalStruct lval;
  int nerrs;

  LvalStruct val;

  int len;

  state = 0;
  errstatus = 0;
  nerrs = 0;
  char_ = EMPTY;

  ssp = ss - 1;
  vsp = vs;

  newstate:

  *++ssp = state;

  if (ssp >= ss + stacksize - 1)
  {
    LvalStruct *vs1 = vs;
    short *ss1 = ss;

    size_t size = ssp - ss + 1;

    if (stacksize >= MAXDEPTH)
    {
      fatal_error("bison internal error: parser stack overflow");
      return 2;
    }
    stacksize *= 2;
    if (stacksize > MAXDEPTH)
      stacksize = MAXDEPTH;
    ss = (short *) alloca ( (unsigned)(stacksize * sizeof (*ssp)) );
    memcpy((UCHAR *)ss, (UCHAR *)ss1, size * sizeof (*ssp));
    vs = (LvalStruct *) alloca ( (unsigned)(stacksize * sizeof (*vsp)) );
    memcpy((UCHAR *)vs, (UCHAR *)vs1, size * sizeof (*vsp));

    ssp = ss + size - 1;
    vsp = vs + size - 1;

    if (ssp >= ss + stacksize - 1)
      return 1;
  }

  goto backup;

  backup:

  n = pact[state];
  if (n == FLAG)
    goto default_;

  if (char_ == EMPTY)
  {
    char_ = lex(lval);
  }

  if (char_ <= 0)
  {
    char1 = 0;
    char_ = EOF_;

  }
  else
  {
    char1 = TRANSLATE(char_);

  }

  n += char1;
  if (n < 0 || n > LAST || check[n] != char1)
    goto default_;

  n = table[n];

  if (n < 0)
  {
    if (n == FLAG)
      goto errlab;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errlab;

  if (n == FINAL)
    return 0;

  if (char_ != EOF_)
    char_ = EMPTY;

  *++vsp = lval;

  if (errstatus) errstatus--;

  state = n;
  goto newstate;

  default_:

  n = defact[state];
  if (n == 0)
    goto errlab;

  reduce:
  len = r2[n];
  if (len > 0)
    val = vsp[1-len];

  switch (n) {
    case 1:

{
    parser_node_p = 0;
    return 1;;
  ;
    break;}
case 2:

{
    DIE_IF( vsp[-1]._tag != LvalStruct::NODE );
    parser_node_p = vsp[-1]._node;
    return 0;;
  ;
    break;}
case 3:

{
    parser_node_p = 0;
    return 1;;
  ;
    break;}
case 4:

{
    parse_nop( val, vsp[0] );
  ;
    break;}
case 5:

{
    parse_binary_op( val, SY_add, vsp[-2], vsp[0] );
  ;
    break;}
case 6:

{
    parse_binary_op( val, SY_sub, vsp[-2], vsp[0] );
  ;
    break;}
case 7:

{
    parse_nop( val, vsp[0] );
  ;
    break;}
case 8:

{
    parse_binary_op( val, SY_mul, vsp[-2], vsp[0] );
  ;
    break;}
case 9:

{
    parse_binary_op( val, SY_div, vsp[-2], vsp[0] );
  ;
    break;}
case 10:

{
    parse_binary_op( val, SY_mul, vsp[-1], vsp[0] );
  ;
    break;}
case 11:

{
    parse_nop( val, vsp[0] );
  ;
    break;}
case 12:

{
    parse_nop( val, vsp[0] );
  ;
    break;}
case 13:

{
    parse_unary_op( val, SY_sub, vsp[0] );
  ;
    break;}
case 14:

{
    parse_nop( val, vsp[0] );
  ;
    break;}
case 15:

{
    parse_binary_op( val, SY_pow, vsp[-2], vsp[0] );
  ;
    break;}
case 16:

{
    parse_number( val, vsp[0] );
  ;
    break;}
case 17:

{
    parse_identifier( val, vsp[0] );
  ;
    break;}
case 18:

{
    parse_nop( val, vsp[-1] );
  ;
    break;}
case 19:

{
    parse_unary_fn( val, vsp[-3], vsp[-1] );
  ;
    break;}
case 20:

{
    parse_binary_fn( val, vsp[-5], vsp[-3], vsp[-1] );
  ;
    break;}

  }
  vsp -= len;
  ssp -= len;

  *++vsp = val;
  n = r1[n];

  state = pgoto[n - NTBASE] + *ssp;
  if (state >= 0 && state <= LAST && check[state] == *ssp)
    state = table[state];
  else
    state = defgoto[n - NTBASE];

  goto newstate;

  errlab:

  if (! errstatus)
  {
    ++nerrs;
    error("parse error");
  }

  goto errlab1;
  errlab1:

  if (errstatus == 3)
  {
    if (char_ == EOF_)
      return 1;

    char_ = EMPTY;
  }

  errstatus = 3;

  goto errhandle;

  errdefault:

  errpop:

  if (ssp == ss) return 1;
  vsp--;
  state = *--ssp;

  errhandle:

  n = pact[state];
  if (n == FLAG)
    goto errdefault;

  n += TERROR;
  if (n < 0 || n > LAST || check[n] != TERROR)
    goto errdefault;

  n = table[n];
  if (n < 0)
  {
    if (n == FLAG)
      goto errpop;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errpop;

  if (n == FINAL)
    return 0;

  *++vsp = lval;

  state = n;
  goto newstate;
}

#if !defined(DISABLE_EVAL_NAMESPACE)
} // namespace eval
#endif

#if defined(__sgi) && !defined(__GNUG__)
#pragma reset woff 1110
#endif
