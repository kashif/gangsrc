/* GANG Software
 * BASE/vrml/Parser.H
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++


#ifndef vrml_Parser_INCLUDED
#define vrml_Parser_INCLUDED

/*
  Acknowledgements:
  This code is modified from a VRML 2.0 parser by Gavin Bell and Daniel Woods
  Copyright (C) 1996 Silicon Graphics, Inc.
*/

#include <iostream>
#include <slist>
#include "Lexer.H"

namespace vrml {

class Parser
  :
  public Lexer
{

public:
  Parser();
  virtual ~Parser();

private:

  public:
  void read( io::Istream &in );
protected:
  virtual void error( char const *message );

  struct Material
  {
    Real ambientIntensity;
    Real diffuseColor[3];
    Real emissiveColor[3];
    Real shininess;
    Real specularColor[3];
    Real transparency;
  };

  struct Light
  {
    enum { POINT, DIRECTIONAL, SPOT } type;
    Real ambientIntensity;
    Real attenuation[3];
    Real beamWidth;
    Real color[3];
    Real cutOffAngle;
    Real direction[3];
    Real intensity;
    Real location[3];
    bool on;
    Real radius;
  };

  struct IndexedFaceSet
  {
    base::vector<Real> color;
    base::vector<Real> coord;
    base::vector<Real> normal;
    base::vector<Real> texCoord;
    bool ccw;
    base::vector<int> colorIndex;
    bool colorPerVertex;
    bool convex;
    base::vector<int> coordIndex;
    Real creaseAngle;
    base::vector<int> normalIndex;
    bool normalPerVertex;
    bool solid;
    base::vector<int> texCoordIndex;
  };

  struct Background
  {
    base::vector<Real> skyColor;
    base::vector<Real> skyAngle;
    base::vector<Real> groundColor;
    base::vector<Real> groundAngle;
    base::vector<base::String> backUrl;
    base::vector<base::String> frontUrl;
    base::vector<base::String> leftUrl;
    base::vector<base::String> rightUrl;
    base::vector<base::String> bottomUrl;
    base::vector<base::String> topUrl;
  };

  virtual void material( Material const & ) {};
  virtual void light( Light const & ) {};
  virtual void indexedFaceSet( IndexedFaceSet const & ) {};
  virtual void background( Background const & ) {};

  enum  FieldType {
    NO_FIELD,

    SF_BOOL, SF_COLOR, SF_FLOAT, SF_IMAGE, SF_INT32, SF_ROTATION, SF_STRING,
    SF_TIME, SF_VEC2F, SF_VEC3F, SF_NODE,

    MF_COLOR, MF_FLOAT, MF_INT32, MF_ROTATION, MF_STRING, MF_VEC2F, MF_VEC3F,
    MF_NODE
  };
  void addNode();
  void beginProto(base::String const &);
  void endProto();
  void addField(base::String const &type, base::String const &name);
  void addEventIn(base::String const &type, base::String const &name);
  void addEventOut(base::String const &type, base::String const &name);
  void addExposedField(base::String const &type, base::String const &name);
  void setFieldDefault(base::String const &fieldName);
  void enterNode(base::String const &name);
  void exitNode(base::String const &name);
  void enterField(base::String const &name);
  void exitField(base::String const &name, LvalStruct const & );
  void addScriptEventIn(base::String const &type, base::String const &name);
  void addScriptEventOut(base::String const &type, base::String const &name);
  void enterScriptField(base::String const &type, base::String const &name);
  void exitScriptField();
  void addRoute(base::String const &, base::String const &, base::String const &,
                base::String const &);
  void addIS(base::String const &);
  void addEventIS(base::String const &, base::String const &);
  void setExpect(FieldType type);
  void setExpect(base::String const &fieldType, int flag);

  std::slist<base::String> currentNode;
private:
  Material _material;
  Light _light;
  IndexedFaceSet _indexedFaceSet;
  Background _background;

  void set( Real [], Real, uint n );
  void copy( Real [], Real const [], uint n );

  void resetLight();
  virtual void cleanup() {}

protected:

  int parse();

private:

  static int const FINAL;
  static int const FLAG;
  static int const NTBASE;
  static int const LAST;
  static int const EMPTY;
  static int const EOF_;
  static int const TERROR;
  static int const ERRCODE;
  static int const INITDEPTH;
  static size_t const MAXDEPTH;
  static UCHAR const translate[];
  static short const r1[];
  static short const r2[];
  static short const defact[];
  static short const defgoto[];
  static short const pact[];
  static short const pgoto[];
  static short const table[];
  static short const check[];
  int TRANSLATE( int x)
    { return x <= 288 ? translate[x] : 69; }

  // disabled
  Parser( Parser const & );
  // disabled
  Parser &operator=( Parser const & );


};

} // namespace vrml

#endif // vrml_Parser_INCLUDED

