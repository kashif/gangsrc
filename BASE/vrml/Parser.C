/* GANG Software
 * BASE/vrml/Parser.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++

#include <stdlib.h>
#include <string.h>
#include <alloca.h>
#include "Parser.H"

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif

/*
  Acknowledgements:
  This code is modified from a VRML 2.0 parser by Gavin Bell and Daniel Woods
  Copyright (C) 1996 Silicon Graphics, Inc.
*/

#include "base/Use.h"
#include "math/Math.H"

namespace vrml {
// constructor
Parser::Parser() : Lexer() {}

// destructor
Parser::~Parser() {}

void
Parser::
read( io::Istream &in )
{
  _initialize();

  expectCoordIndex = 0;
  currentNode.clear();

  _stream = &in;
  parse();
}

void
Parser::
error(char const message[])
{
  setExpect(NO_FIELD);
  cleanup();
  throw( io::ReadException(io::ReadException::PARSE_ERROR,
	 _stream->filename(), _lineno, message) );
}


void
Parser::
beginProto(base::String const &)
{
}

void
Parser::
endProto()
{
}

void
Parser::
addField(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
addEventIn(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
addEventOut(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
addExposedField(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
setFieldDefault(base::String const &fieldName)
{
  USE(fieldName);
}

void
Parser::
enterNode(base::String const &name)
{
  if ( name == "Material" )
  {
    _material.ambientIntensity = 0.2;
    set( _material.diffuseColor, 0.8, 3 );
    set( _material.emissiveColor, 0.0, 3 );
    _material.shininess = 0.2;
    set( _material.specularColor, 0.0, 3 );
    _material.transparency = 0.0;
  }
  else if ( name == "PointLight" ||
            name == "DirectionalLight" ||
            name == "SpotLight" )
  {
    _light.ambientIntensity = 0.0;
    set(_light.attenuation, 0.0, 3 );
    _light.attenuation[0] = 1.0;
    _light.beamWidth = math::pi/2.0f;
    set( _light.color, 1.0, 3 );
    _light.cutOffAngle = math::pi/4.0f;
    set( _light.direction, 0.0, 2 );
    _light.direction[2] = -1.0;
    _light.intensity = 1.0;
    set( _light.location, 0.0, 2 );
    _light.location[2] = 1.0;
    _light.on = true;
    _light.radius = 100.0;
    if ( name == "PointLight" ) { _light.type = Light::POINT; }
    else if ( name == "DirectionalLight" ) { _light.type = Light::DIRECTIONAL; }
    else { _light.type = Light::SPOT; }
  }
  else if ( name == "IndexedFaceSet" )
  {
    _indexedFaceSet.color.clear();
    _indexedFaceSet.coord.clear();
    _indexedFaceSet.normal.clear();
    _indexedFaceSet.texCoord.clear();
    _indexedFaceSet.ccw = true;
    _indexedFaceSet.colorIndex.clear();
    _indexedFaceSet.colorPerVertex= true;
    _indexedFaceSet.convex = true;
    _indexedFaceSet.coordIndex.clear();
    _indexedFaceSet.creaseAngle = 0.0;
    _indexedFaceSet.normalIndex.clear();
    _indexedFaceSet.normalPerVertex = true;
    _indexedFaceSet.solid = true;
    _indexedFaceSet.texCoordIndex.clear();
  }
  else if ( name == "Background" )
  {
    _background.skyColor.clear();
    _background.skyAngle.clear();
    _background.groundColor.clear();
    _background.groundAngle.clear();
    _background.backUrl.clear();
    _background.frontUrl.clear();
    _background.leftUrl.clear();
    _background.rightUrl.clear();
    _background.bottomUrl.clear();
    _background.topUrl.clear();
  }
}

void
Parser::
exitNode(base::String const &name)
{
  if ( name == "Material" )
  {
    material( _material );
  }
  else if ( name == "PointLight" ||
            name == "DirectionalLight" ||
            name == "SpotLight" )
  {
    light( _light );
  }
  else if ( name == "IndexedFaceSet" )
  {
    indexedFaceSet( _indexedFaceSet );
  }
  else if ( name == "Background" )
  {
    background( _background );
  }
}

void
Parser::
enterField(base::String const &name)
{
  USE(name);
}

void
Parser::
exitField(base::String const &name, LvalStruct const &v )
{
  if ( currentNode.front() == "Material" )
  {
    if (name == "ambientIntesity")
    {
      _material.ambientIntensity = v._float;
    }
    else if (name == "diffuseColor")
    {
      copy( _material.diffuseColor, v._floatp, 3 );
    }
    else if (name == "emissiveColor")
    {
      copy( _material.emissiveColor, v._floatp, 3 );
    }
    else if (name == "shininess")
    {
      _material.shininess = v._float;
    }
    else if (name == "specularColor")
    {
      copy( _material.specularColor, v._floatp, 3 );
    }
    else if (name == "transparency")
    {
      _material.transparency = v._float;
    }
  }
  else if ( currentNode.front() == "PointLight" ||
            currentNode.front() == "DirectionalLight" ||
            currentNode.front() == "SpotLight" )
  {
    if (name == "ambientIntesity")
    {
      _light.ambientIntensity = v._float;
    }
    else if ( name == "attenuation" )
    {
      copy( _light.attenuation, v._floatp, 3 );
    }
    else if ( name == "beamWidth" )
    {
      _light.beamWidth = v._float;
    }
    else if ( name == "color" )
    {
      copy( _light.color, v._floatp, 3 );
    }
    else if ( name == "cutOffAngle" )
    {
      _light.cutOffAngle = v._float;
    }
    else if ( name == "direction" )
    {
      copy( _light.direction, v._floatp, 3 );
    }
    else if ( name == "intensity" )
    {
      _light.intensity = v._float;
    }
    else if ( name == "location" )
    {
      copy( _light.location, v._floatp, 3 );
    }
    else if ( name == "on" )
    {
      _light.on = v._bool;
    }
    else if ( name == "radius" )
    {
      _light.radius = v._float;
    }
  }
  else if ( currentNode.front() == "IndexedFaceSet" )
  {
    if ( name == "ccw" )
    {
      _indexedFaceSet.ccw = v._bool;
    }
    else if ( name == "colorIndex" )
    {
      _indexedFaceSet.colorIndex = v._intv;
    }
    else if ( name == "colorPerVertex" )
    {
      _indexedFaceSet.colorPerVertex = v._bool;
    }
    else if ( name == "convex" )
    {
      _indexedFaceSet.convex = v._bool;
    }
    else if ( name == "coordIndex" )
    {
      // check for out-of-range indices and faces with 0 vertices
      uint c = 0;
      uint i;
      for ( i = 0; i < v._intv.size(); i++ )
      {
        if (v._intv[i] >= 0)
        {
          if (v._intv[i] > (int)_indexedFaceSet.coord.size())
          { error( "face index is out of range" ); }
          c++;
        }
        else
        {
#if 0
          if (c == 0)
          { error( "face has zero vertices" ); }
#endif
          c = 0;
        }
      }
      _indexedFaceSet.coordIndex = v._intv;
    }
    else if ( name == "creaseAngle" )
    {
      _indexedFaceSet.creaseAngle = v._float;
    }
    else if ( name == "normalIndex" )
    {
      _indexedFaceSet.normalIndex = v._intv;
    }
    else if ( name == "normalPerVertex" )
    {
      _indexedFaceSet.normalPerVertex = v._bool;
    }
    else if ( name == "solid" )
    {
      _indexedFaceSet.solid = v._bool;
    }
    else if ( name == "texCoordIndex" )
    {
      _indexedFaceSet.texCoordIndex = v._intv;
    }
  }
  else if ( currentNode.front() == "Coordinate" )
  {
    if ( name == "point" )
    {
#if 0
      if ( v._floatv.size() == 0 )
      { error( "zero vertices"); }
#endif
      if ( v._floatv.size() % 3 != 0 )
      { error( "number of vertex coordinates not a multiple of three"); }

      // NOTE: inefficient: should pass a pointer and length
      _indexedFaceSet.coord = v._floatv;
    }
  }
  else if ( currentNode.front() == "Color" )
  {
    if ( name == "color" )
    {
      if ( v._floatv.size() != _indexedFaceSet.coord.size() )
      { error( "color count is unequal to vertex count" ); }
      _indexedFaceSet.color = v._floatv;
    }
  }
  else if ( currentNode.front() == "Background" )
  {
    if ( name == "skyColor" )
    {
      _background.skyColor = v._floatv;
    }
    else if ( name == "skyAngle" )
    {
      _background.skyAngle = v._floatv;
    }
    else if ( name == "groundColor" )
    {
      _background.groundColor = v._floatv;
    }
    else if ( name == "groundAngle" )
    {
      _background.groundAngle = v._floatv;
    }
    else if ( name == "backUrl" )
    {
      _background.backUrl = v._stringv;
    }
    else if ( name == "frontUrl" )
    {
      _background.frontUrl = v._stringv;
    }
    else if ( name == "leftUrl" )
    {
      _background.leftUrl = v._stringv;
    }
    else if ( name == "rightUrl" )
    {
      _background.rightUrl = v._stringv;
    }
    else if ( name == "topUrl" )
    {
      _background.topUrl = v._stringv;
    }
    else if ( name == "bottomUrl" )
    {
      _background.bottomUrl = v._stringv;
    }
  }
}


void
Parser::
addScriptEventIn(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
addScriptEventOut(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
enterScriptField(base::String const &type, base::String const &name)
{
  USE(type);
  USE(name);
}

void
Parser::
exitScriptField()
{
}


void
Parser::
addNode()
{
}

void
Parser::
addRoute(base::String const &, base::String const &, base::String const &, base::String const &)
{
}

void
Parser::
addIS(base::String const &)
{
}

void
Parser::
addEventIS(base::String const &, base::String const &)
{
}


void
Parser::
set( Real A[], Real a, uint n )
{
  uint i;
  for ( i = 0; i < n; i++ )
  {
    A[i] = a;
  }
}

void
Parser::
copy( Real A[], Real const B[], uint n )
{
  uint i;
  for ( i = 0; i < n; i++ )
  {
    A[i] = B[i];
  }
}

void
Parser::
resetLight()
{
}

void
Parser::
setExpect( base::String const &fieldName, int flag )
{
  struct NameCodePair { char const *name; int code; };

  static NameCodePair const table0[] = {
    { "MFColor", VP_MF_COLOR },
    { "MFFloat", VP_MF_FLOAT },
    { "MFInt32", VP_MF_INT32 },
    { "MFRotation", VP_MF_ROTATION },
    { "MFString", VP_MF_STRING },
    { "MFVec2f", VP_MF_VEC2F },
    { "MFVec3f", VP_MF_VEC3F },
    { "MFNode",  VP_MF_NODE },
    { "SFBool", VP_SF_BOOL },
    { "SFColor", VP_SF_COLOR },
    { "SFFloat", VP_SF_FLOAT },
    { "SFImage", VP_SF_IMAGE },
    { "SFInt32", VP_SF_INT32 },
    { "SFNode",  VP_SF_NODE },
    { "SFRotation", VP_SF_ROTATION },
    { "SFString", VP_SF_STRING },
    { "SFTime", VP_SF_TIME },
    { "SFVec2f", VP_SF_VEC2F },
    { "SFVec3f", VP_SF_VEC3F },
  };
  static NameCodePair const table1[] = {
    { "Anchor::bboxCenter", VP_SF_VEC3F },
    { "Anchor::bboxSize", VP_SF_VEC3F },
    { "Anchor::children", VP_MF_NODE },
    { "Anchor::description", VP_SF_STRING },
    { "Anchor::parameter", VP_MF_STRING },
    { "Anchor::url", VP_MF_STRING },
    { "Appearance::material", VP_SF_NODE },
    { "Appearance::texture", VP_SF_NODE },
    { "Appearance::textureTransform", VP_SF_NODE },
    { "AudioClip::description", VP_SF_STRING },
    { "AudioClip::loop", VP_SF_BOOL },
    { "AudioClip::pitch", VP_SF_FLOAT },
    { "AudioClip::startTime", VP_SF_TIME },
    { "AudioClip::stopTime", VP_SF_TIME },
    { "AudioClip::url", VP_MF_STRING },
    { "Background::backUrl", VP_MF_STRING },
    { "Background::bottomUrl", VP_MF_STRING },
    { "Background::frontUrl", VP_MF_STRING },
    { "Background::groundAngle", VP_MF_FLOAT },
    { "Background::groundColor", VP_MF_COLOR },
    { "Background::leftUrl", VP_MF_STRING },
    { "Background::rightUrl", VP_MF_STRING },
    { "Background::skyAngle", VP_MF_FLOAT },
    { "Background::skyColor", VP_MF_COLOR },
    { "Background::topUrl", VP_MF_STRING },
    { "Billboard::axisOfRotation", VP_SF_VEC3F },
    { "Billboard::bboxCenter", VP_SF_VEC3F },
    { "Billboard::bboxSize", VP_SF_VEC3F },
    { "Billboard::children", VP_MF_NODE },
    { "Box::size", VP_SF_VEC3F },
    { "Collision::bboxCenter", VP_SF_VEC3F },
    { "Collision::bboxSize", VP_SF_VEC3F },
    { "Collision::children", VP_MF_NODE },
    { "Collision::collide", VP_SF_BOOL },
    { "Collision::proxy", VP_SF_NODE },
    { "Color::color", VP_MF_COLOR },
    { "ColorInterpolator::key", VP_MF_FLOAT },
    { "ColorInterpolator::keyValue", VP_MF_COLOR },
    { "Cone::bottom", VP_SF_BOOL },
    { "Cone::bottomRadius", VP_SF_FLOAT },
    { "Cone::height", VP_SF_FLOAT },
    { "Cone::side", VP_SF_BOOL },
    { "Coordinate::point", VP_MF_VEC3F },
    { "CoordinateInterpolator::key", VP_MF_FLOAT },
    { "CoordinateInterpolator::keyValue", VP_MF_VEC3F },
    { "Cylinder::bottom", VP_SF_BOOL },
    { "Cylinder::height", VP_SF_FLOAT },
    { "Cylinder::radius", VP_SF_FLOAT },
    { "Cylinder::side", VP_SF_BOOL },
    { "Cylinder::top", VP_SF_BOOL },
    { "CylinderSensor::autoOffset", VP_SF_BOOL },
    { "CylinderSensor::diskAngle", VP_SF_FLOAT },
    { "CylinderSensor::enabled", VP_SF_BOOL },
    { "CylinderSensor::maxAngle", VP_SF_FLOAT },
    { "CylinderSensor::minAngle", VP_SF_FLOAT },
    { "CylinderSensor::offset", VP_SF_FLOAT },
    { "DirectionalLight::ambientIntensity", VP_SF_FLOAT },
    { "DirectionalLight::color", VP_SF_COLOR },
    { "DirectionalLight::direction", VP_SF_VEC3F },
    { "DirectionalLight::intensity", VP_SF_FLOAT },
    { "DirectionalLight::on", VP_SF_BOOL },
    { "ElevationGrid::ccw", VP_SF_BOOL },
    { "ElevationGrid::color", VP_SF_NODE },
    { "ElevationGrid::colorPerVertex", VP_SF_BOOL },
    { "ElevationGrid::creaseAngle", VP_SF_FLOAT },
    { "ElevationGrid::height", VP_MF_FLOAT },
    { "ElevationGrid::normal", VP_SF_NODE },
    { "ElevationGrid::normalPerVertex", VP_SF_BOOL },
    { "ElevationGrid::solid", VP_SF_BOOL },
    { "ElevationGrid::texCoord", VP_SF_NODE },
    { "ElevationGrid::xDimension", VP_SF_INT32 },
    { "ElevationGrid::xSpacing", VP_SF_FLOAT },
    { "ElevationGrid::zDimension", VP_SF_INT32 },
    { "ElevationGrid::zSpacing", VP_SF_FLOAT },
    { "Extrusion::beginCap", VP_SF_BOOL },
    { "Extrusion::ccw", VP_SF_BOOL },
    { "Extrusion::convex", VP_SF_BOOL },
    { "Extrusion::creaseAngle", VP_SF_FLOAT },
    { "Extrusion::crossSection", VP_MF_VEC2F },
    { "Extrusion::endCap", VP_SF_BOOL },
    { "Extrusion::orientation", VP_MF_ROTATION },
    { "Extrusion::scale", VP_MF_VEC2F },
    { "Extrusion::solid", VP_SF_BOOL },
    { "Extrusion::spine", VP_MF_VEC3F },
    { "Fog::color", VP_SF_COLOR },
    { "Fog::fogType", VP_SF_STRING },
    { "Fog::visibilityRange", VP_SF_FLOAT },
    { "FontStyle::family", VP_MF_STRING },
    { "FontStyle::horizontal", VP_SF_BOOL },
    { "FontStyle::justify", VP_MF_STRING },
    { "FontStyle::language", VP_SF_STRING },
    { "FontStyle::leftToRight", VP_SF_BOOL },
    { "FontStyle::size", VP_SF_FLOAT },
    { "FontStyle::spacing", VP_SF_FLOAT },
    { "FontStyle::style", VP_SF_STRING },
    { "FontStyle::topToBottom", VP_SF_BOOL },
    { "Group::bboxCenter", VP_SF_VEC3F },
    { "Group::bboxSize", VP_SF_VEC3F },
    { "Group::children", VP_MF_NODE },
    { "ImageTexture::repeatS", VP_SF_BOOL },
    { "ImageTexture::repeatT", VP_SF_BOOL },
    { "ImageTexture::url", VP_MF_STRING },
    { "IndexedFaceSet::ccw", VP_SF_BOOL },
    { "IndexedFaceSet::color", VP_SF_NODE },
    { "IndexedFaceSet::colorIndex", VP_MF_INT32 },
    { "IndexedFaceSet::colorPerVertex", VP_SF_BOOL },
    { "IndexedFaceSet::convex", VP_SF_BOOL },
    { "IndexedFaceSet::coord", VP_SF_NODE },
    { "IndexedFaceSet::coordIndex", VP_MF_INT32 },
    { "IndexedFaceSet::creaseAngle", VP_SF_FLOAT },
    { "IndexedFaceSet::normal", VP_SF_NODE },
    { "IndexedFaceSet::normalIndex", VP_MF_INT32 },
    { "IndexedFaceSet::normalPerVertex", VP_SF_BOOL },
    { "IndexedFaceSet::solid", VP_SF_BOOL },
    { "IndexedFaceSet::texCoord", VP_SF_NODE },
    { "IndexedFaceSet::texCoordIndex", VP_MF_INT32 },
    { "IndexedLineSet::color", VP_SF_NODE },
    { "IndexedLineSet::colorIndex", VP_MF_INT32 },
    { "IndexedLineSet::colorPerVertex", VP_SF_BOOL },
    { "IndexedLineSet::coord", VP_SF_NODE },
    { "IndexedLineSet::coordIndex", VP_MF_INT32 },
    { "Inline::bboxCenter", VP_SF_VEC3F },
    { "Inline::bboxSize", VP_SF_VEC3F },
    { "Inline::url", VP_MF_STRING },
    { "LOD::center", VP_SF_VEC3F },
    { "LOD::level", VP_MF_NODE },
    { "LOD::range", VP_MF_FLOAT },
    { "Material::ambientIntensity", VP_SF_FLOAT },
    { "Material::diffuseColor", VP_SF_COLOR },
    { "Material::emissiveColor", VP_SF_COLOR },
    { "Material::shininess", VP_SF_FLOAT },
    { "Material::specularColor", VP_SF_COLOR },
    { "Material::transparency", VP_SF_FLOAT },
    { "MovieTexture::loop", VP_SF_BOOL },
    { "MovieTexture::repeatS", VP_SF_BOOL },
    { "MovieTexture::repeatT", VP_SF_BOOL },
    { "MovieTexture::speed", VP_SF_FLOAT },
    { "MovieTexture::startTime", VP_SF_TIME },
    { "MovieTexture::stopTime", VP_SF_TIME },
    { "MovieTexture::url", VP_MF_STRING },
    { "NavigationInfo::avatarSize", VP_MF_FLOAT },
    { "NavigationInfo::headlight", VP_SF_BOOL },
    { "NavigationInfo::speed", VP_SF_FLOAT },
    { "NavigationInfo::type", VP_MF_STRING },
    { "NavigationInfo::visibilityLimit", VP_SF_FLOAT },
    { "Normal::vector", VP_MF_VEC3F },
    { "NormalInterpolator::key", VP_MF_FLOAT },
    { "NormalInterpolator::keyValue", VP_MF_VEC3F },
    { "OrientationInterpolator::key", VP_MF_FLOAT },
    { "OrientationInterpolator::keyValue", VP_MF_ROTATION },
    { "PixelTexture::image", VP_SF_IMAGE },
    { "PixelTexture::repeatS", VP_SF_BOOL },
    { "PixelTexture::repeatT", VP_SF_BOOL },
    { "PlaneSensor::autoOffset", VP_SF_BOOL },
    { "PlaneSensor::enabled", VP_SF_BOOL },
    { "PlaneSensor::maxPosition", VP_SF_VEC2F },
    { "PlaneSensor::minPosition", VP_SF_VEC2F },
    { "PlaneSensor::offset", VP_SF_VEC3F },
    { "PointLight::ambientIntensity", VP_SF_FLOAT },
    { "PointLight::attenuation", VP_SF_VEC3F },
    { "PointLight::color", VP_SF_COLOR },
    { "PointLight::intensity", VP_SF_FLOAT },
    { "PointLight::location", VP_SF_VEC3F },
    { "PointLight::on", VP_SF_BOOL },
    { "PointLight::radius", VP_SF_FLOAT },
    { "PointSet::color", VP_SF_NODE },
    { "PointSet::coord", VP_SF_NODE },
    { "PositionInterpolator::key", VP_MF_FLOAT },
    { "PositionInterpolator::keyValue", VP_MF_VEC3F },
    { "ProximitySensor::center", VP_SF_VEC3F },
    { "ProximitySensor::enabled", VP_SF_BOOL },
    { "ProximitySensor::size", VP_SF_VEC3F },
    { "ScalarInterpolator::key", VP_MF_FLOAT },
    { "ScalarInterpolator::keyValue", VP_MF_FLOAT },
    { "Script::directOutput", VP_SF_BOOL },
    { "Script::mustEvaluate", VP_SF_BOOL },
    { "Script::url", VP_MF_STRING },
    { "Shape::appearance", VP_SF_NODE },
    { "Shape::geometry", VP_SF_NODE },
    { "Sound::direction", VP_SF_VEC3F },
    { "Sound::intensity", VP_SF_FLOAT },
    { "Sound::location", VP_SF_VEC3F },
    { "Sound::maxBack", VP_SF_FLOAT },
    { "Sound::maxFront", VP_SF_FLOAT },
    { "Sound::minBack", VP_SF_FLOAT },
    { "Sound::minFront", VP_SF_FLOAT },
    { "Sound::priority", VP_SF_FLOAT },
    { "Sound::source", VP_SF_NODE },
    { "Sound::spatialize", VP_SF_BOOL },
    { "Sphere::radius", VP_SF_FLOAT },
    { "SphereSensor::autoOffset", VP_SF_BOOL },
    { "SphereSensor::enabled", VP_SF_BOOL },
    { "SphereSensor::offset", VP_SF_ROTATION },
    { "SpotLight::ambientIntensity", VP_SF_FLOAT },
    { "SpotLight::attenuation", VP_SF_VEC3F },
    { "SpotLight::beamWidth", VP_SF_FLOAT },
    { "SpotLight::color", VP_SF_COLOR },
    { "SpotLight::cutOffAngle", VP_SF_FLOAT },
    { "SpotLight::direction", VP_SF_VEC3F },
    { "SpotLight::intensity", VP_SF_FLOAT },
    { "SpotLight::location", VP_SF_VEC3F },
    { "SpotLight::on", VP_SF_BOOL },
    { "SpotLight::radius", VP_SF_FLOAT },
    { "Switch::choice", VP_MF_NODE },
    { "Switch::whichChoice", VP_SF_INT32 },
    { "Text::fontStyle", VP_SF_NODE },
    { "Text::length", VP_MF_FLOAT },
    { "Text::maxExtent", VP_SF_FLOAT },
    { "Text::base::String", VP_MF_STRING },
    { "TextureCoordinate::point", VP_MF_VEC2F },
    { "TextureTransform::center", VP_SF_VEC2F },
    { "TextureTransform::rotation", VP_SF_FLOAT },
    { "TextureTransform::scale", VP_SF_VEC2F },
    { "TextureTransform::translation", VP_SF_VEC2F },
    { "TimeSensor::cycleInterval", VP_SF_TIME },
    { "TimeSensor::enabled", VP_SF_BOOL },
    { "TimeSensor::loop", VP_SF_BOOL },
    { "TimeSensor::startTime", VP_SF_TIME },
    { "TimeSensor::stopTime", VP_SF_TIME },
    { "TouchSensor::enabled", VP_SF_BOOL },
    { "Transform::bboxCenter", VP_SF_VEC3F },
    { "Transform::bboxSize", VP_SF_VEC3F },
    { "Transform::center", VP_SF_VEC3F },
    { "Transform::children", VP_MF_NODE },
    { "Transform::rotation", VP_SF_ROTATION },
    { "Transform::scale", VP_SF_VEC3F },
    { "Transform::scaleOrientation", VP_SF_ROTATION },
    { "Transform::translation", VP_SF_VEC3F },
    { "Viewpoint::description", VP_SF_STRING },
    { "Viewpoint::fieldOfView", VP_SF_FLOAT },
    { "Viewpoint::jump", VP_SF_BOOL },
    { "Viewpoint::orientation", VP_SF_ROTATION },
    { "Viewpoint::position", VP_SF_VEC3F },
    { "VisibilitySensor::center", VP_SF_VEC3F },
    { "VisibilitySensor::enabled", VP_SF_BOOL },
    { "VisibilitySensor::size", VP_SF_VEC3F },
    { "WorldInfo::info", VP_MF_STRING },
    { "WorldInfo::title", VP_SF_STRING },
  };

  base::String s;
  if ( flag == 1 )
  {
    assert(!currentNode.empty());
    s = currentNode.front();
    s += "::";
  }
  s += fieldName;

  NameCodePair const *table;
  uint len;

  if (flag == 0)
  {
    table = table0;
    len = sizeof(table0);
  }
  else
  {
    table = table1;
    len = sizeof(table1);
  }
  len /= sizeof(NameCodePair);

  expectToken = 0;
  uint i;
  for ( i = 0; i < len; i++ )
  {
    if ( s == table[i].name )
    {
      expectToken = table[i].code;
      break;
    }
  }
  expectCoordIndex = (fieldName == "coordIndex");
}



// This switch is necessary so the VrmlNodeType code can be independent
// of the parser tokens.

void
Parser::
setExpect(Parser::FieldType type)
{
  switch (type)
  {
  case SF_BOOL:     expectToken = VP_SF_BOOL; break;
  case SF_COLOR:    expectToken = VP_SF_COLOR; break;
  case SF_FLOAT:    expectToken = VP_SF_FLOAT; break;
  case SF_IMAGE:    expectToken = VP_SF_IMAGE; break;
  case SF_INT32:    expectToken = VP_SF_INT32; break;
  case SF_ROTATION: expectToken = VP_SF_ROTATION; break;
  case SF_STRING:   expectToken = VP_SF_STRING; break;
  case SF_TIME:     expectToken = VP_SF_TIME; break;
  case SF_VEC2F:    expectToken = VP_SF_VEC2F; break;
  case SF_VEC3F:    expectToken = VP_SF_VEC3F; break;

  case MF_COLOR:     expectToken = VP_MF_COLOR; break;
  case MF_FLOAT:     expectToken = VP_MF_FLOAT; break;
  case MF_INT32:     expectToken = VP_MF_INT32; break;
  case MF_ROTATION:  expectToken = VP_MF_ROTATION; break;
  case MF_STRING:    expectToken = VP_MF_STRING; break;
  case MF_VEC2F:     expectToken = VP_MF_VEC2F; break;
  case MF_VEC3F:     expectToken = VP_MF_VEC3F; break;

  case MF_NODE:      expectToken = VP_MF_NODE; break;
  case SF_NODE:      expectToken = VP_SF_NODE; break;
  default:    expectToken = 0; break;
  }
}

Parser::
Parser( Parser const & )
{
  abort();
}

Parser &
Parser::
operator=( Parser const & )
{
  abort();
  return *this;
}

int const Parser::FINAL = 133;
int const Parser::NTBASE = 40;
int const Parser::LAST = 139;
int const Parser::EOF_ = 0;
int const Parser::EMPTY = -2;
int const Parser::FLAG = -32768;
int const Parser::TERROR = 1;
int const Parser::ERRCODE = 256;
int const Parser::INITDEPTH = 200;
size_t const Parser::MAXDEPTH = 10000;

Parser::UCHAR const Parser::translate[] =
{     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,    39,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
    35,     2,    36,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,    37,     2,    38,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19,    20,    21,    22,    23,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34
};

short const Parser::r1[] =
{     0,
    40,    41,    41,    42,    42,    42,    43,    44,    43,    43,
    45,    45,    47,    46,    49,    50,    48,    51,    51,    52,
    52,    53,    52,    54,    52,    55,    55,    56,    56,    56,
    56,    57,    59,    58,    60,    60,    62,    61,    61,    61,
    61,    61,    63,    61,    64,    61,    65,    61,    66,    66,
    66,    66,    66,    66,    66,    66,    66,    66,    66,    66,
    66,    66,    66,    66,    66,    66,    66,    66,    66,    66,
    66,    67,    67,    68,    68
};

short const Parser::r2[] =
{     0,
     1,     0,     2,     1,     1,     1,     1,     0,     4,     2,
     1,     1,     0,     9,     0,     0,     8,     0,     2,     3,
     3,     0,     5,     0,     5,     0,     2,     3,     3,     3,
     3,     8,     0,     5,     0,     2,     0,     3,     1,     1,
     3,     3,     0,     5,     0,     6,     0,     6,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     2,     2,     2,     2,     3,
     3,     3,     1,     0,     2
};

short const Parser::defact[] =
{     2,
     1,    33,     0,     0,     0,     0,     0,     3,     4,     5,
    11,    12,     6,     7,     0,     8,    10,    13,    15,     0,
    35,     0,     0,     0,     0,     0,     9,    18,    26,     0,
    37,     0,     0,     0,    34,    40,    39,    36,     0,     0,
     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
    19,     0,     0,     0,     0,    16,    27,     0,     0,    56,
    57,    58,    60,    61,    63,    59,    62,    64,    65,    49,
    50,    51,    52,    53,    54,    55,     0,     0,    38,    41,
    42,    43,     0,     0,     0,     0,     2,     0,     0,     0,
     0,     0,     0,    69,     0,    67,    66,     0,    74,    73,
    68,     0,     0,     0,    20,    21,    22,    24,     0,    28,
    29,    30,    31,    17,    32,    70,    71,     0,     0,     0,
    44,     0,     0,    14,    72,    75,    46,    48,    23,    25,
     0,     0,     0
};

short const Parser::defgoto[] =
{   131,
     1,     8,     9,    22,    10,    11,    23,    12,    24,    92,
    39,    51,   122,   123,    40,    57,    13,    14,    15,    26,
    38,    42,   104,   102,   103,    79,   101,   118
};

short const Parser::pact[] =
{-32768,
    78,-32768,     0,     1,     4,     7,    16,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,    -9,-32768,-32768,-32768,-32768,   -10,
-32768,    27,     5,    10,    33,    -1,-32768,-32768,-32768,    38,
-32768,    44,    49,    50,-32768,-32768,-32768,-32768,    20,    65,
    51,    42,    83,    84,    86,    87,    88,    89,    90,    57,
-32768,    92,    93,    94,    95,-32768,-32768,    60,    97,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,    39,    22,-32768,    96,
    98,-32768,    99,   100,   101,   103,-32768,   105,   106,   107,
   108,    42,   109,-32768,   110,-32768,-32768,   111,-32768,-32768,
-32768,   112,   113,    42,-32768,-32768,-32768,-32768,    11,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,    19,   114,   115,
-32768,    42,    42,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
   116,   119,-32768
};

short const Parser::pgoto[] =
{-32768,
    28,-32768,   -77,-32768,   102,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,   104,   117,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,   -84,-32768,-32768
};

short const Parser::table[] =
{    97,
   100,    31,    16,    17,     5,     6,    18,   114,     7,    19,
    32,    33,    34,     2,     3,     4,     5,     6,    20,   121,
     7,     2,     3,     4,     2,     3,     4,    21,    25,     2,
    98,    46,    47,    48,    49,    30,    35,   129,   130,    28,
   126,     2,     3,     4,    29,    41,    43,    95,   124,    96,
    59,    44,    45,    58,   125,    50,    99,    60,    61,    62,
    63,    64,    65,    66,    67,    68,    69,    70,    71,    72,
    73,    74,    75,    76,    77,    78,    52,    53,    54,    55,
     2,     3,     4,     5,     6,    80,    81,     7,    82,    83,
    84,    85,    86,    87,    88,    89,    90,    91,    93,    94,
    56,   105,   106,   107,   -45,   108,   -47,   110,   111,   112,
   113,   115,   116,   117,   109,   132,   127,   128,   133,     0,
   119,   120,     0,     0,     0,     0,     0,    36,     0,    37,
     0,     0,     0,     0,     0,     0,     0,     0,    27
};

short const Parser::check[] =
{    77,
    78,     3,     3,     3,     6,     7,     3,    92,    10,     3,
    12,    13,    14,     3,     4,     5,     6,     7,     3,   104,
    10,     3,     4,     5,     3,     4,     5,    37,    39,     3,
     9,    12,    13,    14,    15,     3,    38,   122,   123,    35,
   118,     3,     4,     5,    35,     8,     3,     9,    38,    11,
     9,     3,     3,     3,    36,    36,    35,    16,    17,    18,
    19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
    29,    30,    31,    32,    33,    34,    12,    13,    14,    15,
     3,     4,     5,     6,     7,     3,     3,    10,     3,     3,
     3,     3,     3,    37,     3,     3,     3,     3,    39,     3,
    36,     3,     3,     3,     9,     3,     9,     3,     3,     3,
     3,     3,     3,     3,    87,     0,     3,     3,     0,    -1,
     9,     9,    -1,    -1,    -1,    -1,    -1,    26,    -1,    26,
    -1,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    22
};


int
Parser::
parse()
{
  int state;
  int n;
  short *ssp;
  LvalStruct *vsp;
  int errstatus;
  int char1 = 0;

  short ssa[INITDEPTH];
  LvalStruct vsa[INITDEPTH];

  short *ss = ssa;
  LvalStruct *vs = vsa;

  size_t stacksize = INITDEPTH;

  int char_;
  LvalStruct lval;
  int nerrs;

  LvalStruct val;

  int len;

  state = 0;
  errstatus = 0;
  nerrs = 0;
  char_ = EMPTY;

  ssp = ss - 1;
  vsp = vs;

  newstate:

  *++ssp = state;

  if (ssp >= ss + stacksize - 1)
  {
    LvalStruct *vs1 = vs;
    short *ss1 = ss;

    size_t size = ssp - ss + 1;

    if (stacksize >= MAXDEPTH)
    {
      fatal_error("bison internal error: parser stack overflow");
      return 2;
    }
    stacksize *= 2;
    if (stacksize > MAXDEPTH)
      stacksize = MAXDEPTH;
    ss = (short *) alloca ( (unsigned)(stacksize * sizeof (*ssp)) );
    memcpy((UCHAR *)ss, (UCHAR *)ss1, size * sizeof (*ssp));
    vs = (LvalStruct *) alloca ( (unsigned)(stacksize * sizeof (*vsp)) );
    memcpy((UCHAR *)vs, (UCHAR *)vs1, size * sizeof (*vsp));

    ssp = ss + size - 1;
    vsp = vs + size - 1;

    if (ssp >= ss + stacksize - 1)
      return 1;
  }

  goto backup;

  backup:

  n = pact[state];
  if (n == FLAG)
    goto default_;

  if (char_ == EMPTY)
  {
    char_ = lex(lval);
  }

  if (char_ <= 0)
  {
    char1 = 0;
    char_ = EOF_;

  }
  else
  {
    char1 = TRANSLATE(char_);

  }

  n += char1;
  if (n < 0 || n > LAST || check[n] != char1)
    goto default_;

  n = table[n];

  if (n < 0)
  {
    if (n == FLAG)
      goto errlab;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errlab;

  if (n == FINAL)
    return 0;

  if (char_ != EOF_)
    char_ = EMPTY;

  *++vsp = lval;

  if (errstatus) errstatus--;

  state = n;
  goto newstate;

  default_:

  n = defact[state];
  if (n == 0)
    goto errlab;

  reduce:
  len = r2[n];
  if (len > 0)
    val = vsp[1-len];

  switch (n) {
    case 4:

{ addNode(); ;
    break;}
case 8:

{ ; ;
    break;}
case 9:

{ ; ;
    break;}
case 10:

{ ; ;
    break;}
case 13:

{ beginProto(vsp[0]._string); ;
    break;}
case 14:

{ endProto(); ;
    break;}
case 15:

{ beginProto(vsp[0]._string); ;
    break;}
case 16:

{ setExpect(MF_STRING); ;
    break;}
case 17:

{ endProto(); ;
    break;}
case 20:

{ addEventIn(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 21:

{ addEventOut(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 22:

{ setExpect(vsp[-1]._string,0); addField(vsp[-1]._string,vsp[0]._string); ;
    break;}
case 23:

{ setFieldDefault(vsp[-2]._string); ;
    break;}
case 24:

{ setExpect(vsp[-1]._string,0); addExposedField(vsp[-1]._string,vsp[0]._string); ;
    break;}
case 25:

{ setFieldDefault(vsp[-2]._string); ;
    break;}
case 28:

{ addEventIn(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 29:

{ addEventOut(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 30:

{ addField(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 31:

{ addExposedField(vsp[-1]._string, vsp[0]._string);;
    break;}
case 32:

{ addRoute(vsp[-6]._string, vsp[-4]._string, vsp[-2]._string, vsp[0]._string); ;
    break;}
case 33:

{ currentNode.push_front(vsp[0]._string); enterNode(vsp[0]._string); ;
    break;}
case 34:

{ assert( !currentNode.empty() ); exitNode(currentNode.front());
      currentNode.pop_front(); ;
    break;}
case 37:

{ setExpect(vsp[0]._string,1); enterField(vsp[0]._string); ;
    break;}
case 38:

{ exitField(vsp[-2]._string,*vsp); ;
    break;}
case 41:

{ addScriptEventIn(vsp[-1]._string,vsp[0]._string); ;
    break;}
case 42:

{ addScriptEventOut(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 43:

{ setExpect(vsp[-1]._string,0); enterScriptField(vsp[-1]._string, vsp[0]._string); ;
    break;}
case 44:

{ exitScriptField(); ;
    break;}
case 45:

{ addScriptEventIn(vsp[-1]._string,vsp[0]._string); ;
    break;}
case 46:

{ addEventIS(vsp[-3]._string,vsp[0]._string); ;
    break;}
case 47:

{ addScriptEventOut(vsp[-1]._string,vsp[0]._string); ;
    break;}
case 48:

{ addEventIS(vsp[-3]._string,vsp[0]._string); ;
    break;}
case 66:

{ ; ;
    break;}
case 67:

{ ; ;
    break;}
case 68:

{ ; ;
    break;}
case 69:

{ addIS(vsp[0]._string); ;
    break;}
case 70:

{ addIS(vsp[0]._string); ;
    break;}
case 71:

{ addIS(vsp[0]._string); ;
    break;}
case 72:

{ ; ;
    break;}
case 73:

{ ; ;
    break;}
case 74:

{ ; ;
    break;}
case 75:

{ ; ;
    break;}

  }
  vsp -= len;
  ssp -= len;

  *++vsp = val;
  n = r1[n];

  state = pgoto[n - NTBASE] + *ssp;
  if (state >= 0 && state <= LAST && check[state] == *ssp)
    state = table[state];
  else
    state = defgoto[n - NTBASE];

  goto newstate;

  errlab:

  if (! errstatus)
  {
    ++nerrs;
    error("parse error");
  }

  goto errlab1;
  errlab1:

  if (errstatus == 3)
  {
    if (char_ == EOF_)
      return 1;

    char_ = EMPTY;
  }

  errstatus = 3;

  goto errhandle;

  errdefault:

  errpop:

  if (ssp == ss) return 1;
  vsp--;
  state = *--ssp;

  errhandle:

  n = pact[state];
  if (n == FLAG)
    goto errdefault;

  n += TERROR;
  if (n < 0 || n > LAST || check[n] != TERROR)
    goto errdefault;

  n = table[n];
  if (n < 0)
  {
    if (n == FLAG)
      goto errpop;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errpop;

  if (n == FINAL)
    return 0;

  *++vsp = lval;

  state = n;
  goto newstate;
}

} // namespace vrml

#if defined(__sgi) && !defined(__GNUG__)
#pragma reset woff 1110
#endif
