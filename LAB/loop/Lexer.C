/* GANG Software
 * LAB/loop/Lexer.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++

#include <stdlib.h>
#include "Lexer.H"

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif

#include <complex>
#include "Common.H"

namespace loop {

// constructor
Lexer::Lexer() {
  _initialize();
}

// destructor
Lexer::~Lexer() {
  _deinitialize();
}

void
Lexer::
input( char *buf, size_t &result, size_t max_size)
{
  if ( _input_length == 0 )
  {
    result = 0;
  }
  else if (max_size < _input_length )
  {
    memcpy( (void *)buf, (void *)_input_string, max_size );
    result = max_size;

    _input_length -= max_size;
    _input_string += max_size;
  }
  else
  {
    memcpy( (void *)buf, (void *)_input_string, _input_length );

    result = _input_length;

    _input_string = (char *)0;
    _input_length = 0;
  }

}

Lexer::Lexer( Lexer const & )
{
  abort();
}

Lexer &Lexer::operator=( const Lexer & )
{
  abort();
  return *this;
}

int const Lexer::BUFFER_NEW = 0;
int const Lexer::BUFFER_NORMAL = 1;
int const Lexer::BUFFER_EOF_PENDING = 2;
int const Lexer::END_OF_BUFFER_CHAR = 0;
int const Lexer::BUF_SIZE = 16384;
int const Lexer::EOB_ACT_CONTINUE_SCAN = 0;
int const Lexer::EOB_ACT_END_OF_FILE = 1;
int const Lexer::EOB_ACT_LAST_MATCH = 2;
int const Lexer::READ_BUF_SIZE = 8192;
int const Lexer::NUM_RULES = 18;
int const Lexer::END_OF_BUFFER = 19;
int const Lexer::MORE_ADJ = 0;
int const Lexer::INITIAL = 0;
int const Lexer::START_STACK_INCR = 25;
int const Lexer::EXIT_FAILURE_ = 1;
int const Lexer::CONSTANT1 = 35;
int const Lexer::CONSTANT2 = 46;

void Lexer::_initialize()
{
  current_buffer = (BufferState *)0;
  leng = 0;
  hold_char = 0;
  n_chars = 0;
  c_buf_p = (CHAR *)0;
  init = 1;
  start = 0;
  did_buffer_switch_on_eof = 0;
  last_accepting_state = 0;
  last_accepting_cpos = (CHAR *)0;
  start_stack_ptr = 0;
  start_stack_depth = 0;
  start_stack = (int *)0;
}

void Lexer::_deinitialize()
{
  if (current_buffer != (BufferState *)0)
  {
    delete_buffer(current_buffer);
  }
}

Lexer::BufferState::BufferState()
{
  ch_buf = (CHAR *)0;
  buf_pos = (CHAR *)0;
  buf_size = 0;
  n_chars = 0;
  is_our_buffer = 0;
  is_interactive = 0;
  at_bol = 0;
  fill_buffer = 0;
  buffer_status = 0;
}


const short int Lexer::accept[35] =
{   0,
    0,    0,   19,   17,   15,   15,    9,   10,    7,    4,
   16,    5,   17,    8,    1,    3,   11,   12,    6,    2,
   13,   14,   15,    6,    1,    0,    1,    1,    0,    3,
    1,    0,    1,    0
};


const int Lexer::ec[256] =
{   0,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
    1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    1,    1,    1,    1,    1,    1,    1,    4,
    5,    6,    7,    8,    9,   10,   11,   12,   12,   12,
   12,   12,   12,   12,   12,   12,   12,    1,    1,    1,
    1,    1,    1,    1,   13,   13,   13,   13,   14,   13,
   13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
   13,   13,   13,   13,   13,   13,   13,   13,   13,   13,
   15,    1,   16,   17,   13,    1,   13,   13,   13,   13,
   14,   13,   13,   13,   13,   13,   13,   13,   13,   13,
   13,   13,   13,   13,   13,   18,   13,   13,   13,   13,
   13,   13,   19,    1,   20,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1
};


const int Lexer::meta[21] =
{   0,
    1,    1,    1,    1,    1,    1,    2,    1,    2,    1,
    1,    3,    4,    4,    1,    1,    1,    4,    1,    1
};


const short int Lexer::base[37] =
{   0,
    0,    0,   45,   46,   19,   21,   46,   46,   38,   46,
   46,   46,   31,   46,   19,    0,   46,   46,   46,    0,
   46,   46,   24,   46,   22,   25,   29,    0,   23,    0,
    0,   20,   18,   46,   34,   37
};


const short int Lexer::def[37] =
{   0,
   34,    1,   34,   34,   34,   34,   34,   34,   34,   34,
   34,   34,   34,   34,   34,   35,   34,   34,   34,   35,
   34,   34,   34,   34,   34,   34,   25,   15,   36,   35,
   27,   34,   34,    0,   34,   34
};


const short int Lexer::nxt[67] =
{   0,
    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
   14,   15,   16,   16,   17,   18,   19,   20,   21,   22,
   23,   23,   23,   23,   26,   23,   23,   26,   27,   33,
   28,   33,   29,   25,   33,   29,   30,   30,   32,   32,
   31,   29,   25,   24,   34,    3,   34,   34,   34,   34,
   34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
   34,   34,   34,   34,   34,   34
};


const short int Lexer::chk[67] =
{   0,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    5,    5,    6,    6,   15,   23,   23,   25,   15,   33,
   15,   32,   15,   25,   29,   25,   35,   35,   36,   36,
   27,   26,   13,    9,    3,   34,   34,   34,   34,   34,
   34,   34,   34,   34,   34,   34,   34,   34,   34,   34,
   34,   34,   34,   34,   34,   34
};



int Lexer::input()
{
  int c;

  *c_buf_p = hold_char;

  if ( *c_buf_p == END_OF_BUFFER_CHAR )
  {
    if ( c_buf_p < &current_buffer->ch_buf[n_chars] )
      *c_buf_p = '\0';
    else
    {
      int offset = (int)(c_buf_p - text);
      ++c_buf_p;

      switch ( get_next_buffer() )
      {
      case EOB_ACT_LAST_MATCH:
        restart();
      case EOB_ACT_END_OF_FILE:
      {
        if ( wrap() )
          return EOF;

        if ( ! did_buffer_switch_on_eof )
          restart();
        return input();
      }

      case EOB_ACT_CONTINUE_SCAN:
        c_buf_p = text + offset;
        break;
      }
    }
  }

  c = *(unsigned char *) c_buf_p;
  *c_buf_p = '\0';
  hold_char = *++c_buf_p;

  return c;
}


void Lexer::less( int n, CHAR *bp, CHAR *cp )
{
  for (;;)
  {
    *cp = hold_char;
    c_buf_p = cp = bp + n - MORE_ADJ;
    DO_BEFORE_ACTION( bp, cp );
  }
}

void Lexer::DO_BEFORE_ACTION( CHAR *bp, CHAR *cp )
{
  text = bp;
  leng = (int) (cp - bp);
  hold_char = *cp;
  *cp = '\0';
  c_buf_p = cp;
}

int Lexer::lex( LvalStruct &lval )
{
  int current_state;
  CHAR *cp = (char *)0;
  CHAR *bp = (char *)0;
  int act;





  if ( init )
  {
    init = 0;

    if ( ! start )
      start = 1;

    if ( ! current_buffer )
      current_buffer =
        create_buffer( BUF_SIZE );

    load_buffer_state();
  }

  for(;;)
  {
    cp = c_buf_p;


    *cp = hold_char;


    bp = cp;

    current_state = start;
match:
    do
    {
      UCHAR c = ec[(int unsigned)(UCHAR)*cp];
      if ( accept[current_state] )
        {
        last_accepting_state = current_state;
        last_accepting_cpos = cp;
        }
      while ( chk[base[current_state] + c] != current_state )
        {
        current_state = (int) def[current_state];
        if ( current_state >= CONSTANT1 )
                c = meta[(unsigned int) c];
        }
      current_state = nxt[base[current_state] + (unsigned int) c];
      ++cp;
    }
    while ( base[current_state] != CONSTANT2 );

find_action:
    act = accept[current_state];
    if ( act == 0 )
    {
      cp = last_accepting_cpos;
      current_state = last_accepting_state;
      act = accept[current_state];
    }

    text = bp;
    leng = (int) (cp - bp);
    hold_char = *cp;
    *cp = '\0';
    c_buf_p = cp;

do_action:

    switch ( act )
{
      case 0:

      *cp = hold_char;
      cp = last_accepting_cpos;
      current_state = last_accepting_state;
      goto find_action;

case 1:

{
  lval._string = text;
  return TOK_number;
}
  break;
case 2:

{
  lval._string = text;
  return TOK_variable;
}
  break;
case 3:

{
  lval._string = text;
  return TOK_identifier;
}
  break;
case 4:

{
  return TOK_add;
}
  break;
case 5:

{
  return TOK_sub;
}
  break;
case 6:

{
  return TOK_pow;
}
  break;
case 7:

{
  return TOK_mul;
}
  break;
case 8:

{
  return TOK_div;
}
  break;
case 9:

{
  return TOK_Lparen;
}
  break;
case 10:

{
  return TOK_Rparen;
}
  break;
case 11:

{
  return TOK_Lbrack;
}
  break;
case 12:

{
  return TOK_Rbrack;
}
  break;
case 13:

{
  return TOK_Lbrace;
}
  break;
case 14:

{
  return TOK_Rbrace;
}
  break;
case 15:

{
  /* eat up whitespace */
}
  break;
case 16:

{
  return TOK_comma;
}
  break;
case (END_OF_BUFFER + INITIAL + 1):

{
  return TOK_end;
}
  break;
case 17:

{
  return TOK_unknown_character;
}
  break;


case 18:
;
  break;


  case END_OF_BUFFER:
  {

    int amount_of_matched_text = (int) (cp - text) - 1;

    *cp = hold_char;

    if ( current_buffer->buffer_status == BUFFER_NEW )
    {

      n_chars = current_buffer->n_chars;
      current_buffer->buffer_status = BUFFER_NORMAL;
    }


    if ( c_buf_p <= &current_buffer->ch_buf[n_chars] )
    {
      int next_state;

      c_buf_p = text + amount_of_matched_text;

      current_state = get_previous_state();



      next_state = try_NUL_trans( current_state );

      bp = text + MORE_ADJ;

      if ( next_state )
        {

        cp = ++c_buf_p;
        current_state = next_state;
        goto match;
        }

      else
        {
        cp = c_buf_p;
        goto find_action;
        }
    }

    else switch ( get_next_buffer() )
    {
      case EOB_ACT_END_OF_FILE:
        {
        did_buffer_switch_on_eof = 0;

        if ( wrap() )
                {

                c_buf_p = text + MORE_ADJ;

                act = STATE_EOF(START());
                goto do_action;
                }

        else
                {
                if ( ! did_buffer_switch_on_eof )
                        restart();
                }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        c_buf_p =
                text + amount_of_matched_text;

        current_state = get_previous_state();

        cp = c_buf_p;
        bp = text + MORE_ADJ;
        goto match;

      case EOB_ACT_LAST_MATCH:
        c_buf_p =
        &current_buffer->ch_buf[n_chars];

        current_state = get_previous_state();

        cp = c_buf_p;
        bp = text + MORE_ADJ;
        goto find_action;
    }
    break;
  }

  default:
    fatal_error(
      "flex internal error: no action found" );
}
  }
}

int Lexer::get_next_buffer()
{
  CHAR *dest = current_buffer->ch_buf;
  CHAR *source = text;
  int number_to_move, i;
  int ret_val;

  if ( c_buf_p > &current_buffer->ch_buf[n_chars + 1] )
    fatal_error(
    "flex internal error: end of buffer missed" );

  if ( current_buffer->fill_buffer == 0 )
  {
    if ( c_buf_p - text - MORE_ADJ == 1 )
    {

      return EOB_ACT_END_OF_FILE;
    }

    else
    {

      return EOB_ACT_LAST_MATCH;
    }
  }

  number_to_move = (int) (c_buf_p - text) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( current_buffer->buffer_status == BUFFER_EOF_PENDING )

    current_buffer->n_chars = n_chars = 0;

  else
  {
    int num_to_read =
      (int)(current_buffer->buf_size - number_to_move - 1);

    while ( num_to_read <= 0 )
    {
      BufferState * b = current_buffer;

      int c_buf_p_offset =
        (int) (c_buf_p - b->ch_buf);

      if ( b->is_our_buffer )
        {
        int new_size = (int)(b->buf_size * 2);

        if ( new_size <= 0 )
                b->buf_size += b->buf_size / 8;
        else
                b->buf_size *= 2;

        b->ch_buf = (CHAR *)
                flex_realloc( (void *) b->ch_buf,
                                 b->buf_size + 2 );
        }
      else

        b->ch_buf = 0;

      if ( ! b->ch_buf )
        fatal_error(
        "flex internal error: scanner input buffer overflow" );

      c_buf_p = &b->ch_buf[c_buf_p_offset];

      num_to_read = (int)(current_buffer->buf_size -
                        number_to_move - 1);
    }

    if ( num_to_read > READ_BUF_SIZE )
      num_to_read = READ_BUF_SIZE;


    input( (&current_buffer->ch_buf[number_to_move]),
      n_chars, num_to_read );

    current_buffer->n_chars = n_chars;
  }

  if ( n_chars == 0 )
  {
    if ( number_to_move == MORE_ADJ )
    {
      ret_val = EOB_ACT_END_OF_FILE;
      restart();
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      current_buffer->buffer_status =
        BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  n_chars += number_to_move;
  current_buffer->ch_buf[n_chars] = END_OF_BUFFER_CHAR;
  current_buffer->ch_buf[n_chars + 1] = END_OF_BUFFER_CHAR;

  text = &current_buffer->ch_buf[0];

  return ret_val;
}

int Lexer::get_previous_state()
{
  int current_state;
  CHAR *cp;

  current_state = start;

  for ( cp = text + MORE_ADJ; cp < c_buf_p; ++cp )
  {
    UCHAR c = (*cp ? ec[(int unsigned)(UCHAR)*cp] : 1);
    if ( accept[current_state] )
    {
      last_accepting_state = current_state;
      last_accepting_cpos = cp;
    }
    while ( chk[base[current_state] + c] != current_state )
    {
      current_state = (int) def[current_state];
      if ( current_state >= CONSTANT1 )
        c = meta[(unsigned int) c];
    }
    current_state = nxt[base[current_state] + (unsigned int) c];
  }

  return current_state;
}

int Lexer::try_NUL_trans( int current_state )
{
  int is_jam;
  CHAR *cp = c_buf_p;

  UCHAR c = 1;
  if ( accept[current_state] )
  {
    last_accepting_state = current_state;
    last_accepting_cpos = cp;
  }
  while ( chk[base[current_state] + c] != current_state )
  {
    current_state = (int) def[current_state];
    if ( current_state >= CONSTANT1 )
      c = meta[(unsigned int) c];
  }
  current_state = nxt[base[current_state] + (unsigned int) c];
  is_jam = ( current_state == CONSTANT1 - 1 );

  return is_jam ? 0 : current_state;
}

void Lexer::unput( int c, CHAR *bp )
{
  CHAR *cp = c_buf_p;

  *cp = hold_char;

  if ( cp < current_buffer->ch_buf + 2 )
  {

    size_t number_to_move = n_chars + 2;
    CHAR *dest = &current_buffer->ch_buf[
                current_buffer->buf_size + 2];
    CHAR *source =
        &current_buffer->ch_buf[number_to_move];

    while ( source > current_buffer->ch_buf )
      *--dest = *--source;

    cp += (int) (dest - source);
    bp += (int) (dest - source);
    current_buffer->n_chars =
      n_chars = current_buffer->buf_size;

    if ( cp < current_buffer->ch_buf + 2 )
      fatal_error( "flex internal error: push-back overflow" );
  }

  *--cp = (CHAR) c;

  text = bp;
  hold_char = *cp;
  c_buf_p = cp;
}

void Lexer::restart()
{
  if ( ! current_buffer )
    current_buffer = create_buffer( BUF_SIZE );

  init_buffer( current_buffer );
  load_buffer_state();
}

void Lexer::switch_to_buffer( BufferState * new_buffer )
{
  if ( current_buffer == new_buffer )
    return;

  if ( current_buffer )
  {

    *c_buf_p = hold_char;
    current_buffer->buf_pos = c_buf_p;
    current_buffer->n_chars = n_chars;
  }

  current_buffer = new_buffer;
  load_buffer_state();


  did_buffer_switch_on_eof = 1;
}

void Lexer::load_buffer_state()
{
  n_chars = current_buffer->n_chars;
  text = c_buf_p = current_buffer->buf_pos;
  hold_char = *c_buf_p;
}

Lexer::BufferState *Lexer::create_buffer( int size )
{
  BufferState *b;

  b = (BufferState *) flex_alloc( sizeof( BufferState ) );
  if ( ! b )
    fatal_error( "flex internal error: out of memory" );

  b->buf_size = size;


  b->ch_buf = (CHAR *) flex_alloc( b->buf_size + 2 );
  if ( ! b->ch_buf )
    fatal_error( "flex internal error: out of memory" );

  b->is_our_buffer = 1;

  init_buffer( b );

  return b;
}

void Lexer::delete_buffer( BufferState * b )
{
  if ( ! b )
    return;

  if ( b == current_buffer )
  {
    current_buffer = (BufferState *)0;
  }

  if ( b->is_our_buffer )
  {
    flex_free( (void *) b->ch_buf );
  }

  flex_free( (void *) b );
}

void Lexer::init_buffer( BufferState * b )
{
  flush_buffer( b );

  b->fill_buffer = 1;
  b->is_interactive = 0;
}

void Lexer::flush_buffer( BufferState * b )
{
  if ( ! b )
    return;

  b->n_chars = 0;

  b->ch_buf[0] = END_OF_BUFFER_CHAR;
  b->ch_buf[1] = END_OF_BUFFER_CHAR;

  b->buf_pos = &b->ch_buf[0];

  b->at_bol = 1;
  b->buffer_status = BUFFER_NEW;

  if ( b == current_buffer )
    load_buffer_state();
}

Lexer::BufferState *Lexer::scan_buffer( CHAR *base, size_t size )
{
  BufferState * b;

  if ( size < 2 ||
       base[size-2] != END_OF_BUFFER_CHAR ||
       base[size-1] != END_OF_BUFFER_CHAR )

    return 0;

  b = (BufferState *) flex_alloc( sizeof( BufferState ) );
  if ( ! b )
    fatal_error( "flex internal error: out of memory" );

  b->buf_size = size - 2;
  b->buf_pos = b->ch_buf = base;
  b->is_our_buffer = 0;
  b->n_chars = b->buf_size;
  b->is_interactive = 0;
  b->at_bol = 1;
  b->fill_buffer = 0;
  b->buffer_status = BUFFER_NEW;

  switch_to_buffer( b );

  return b;
}

Lexer::BufferState *Lexer::scan_string( const CHAR *str )
{
  int len;
  for ( len = 0; str[len]; ++len )
    ;

  return scan_bytes( str, len );
}

Lexer::BufferState *Lexer::scan_bytes( const CHAR *bytes, int len )
{
  BufferState * b;
  CHAR *buf;
  size_t n;
  int i;


  n = len + 2;
  buf = (CHAR *) flex_alloc( n );
  if ( ! buf )
    fatal_error( "flex internal error: out of memory" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = END_OF_BUFFER_CHAR;

  b = scan_buffer( buf, n );
  if ( ! b )
    fatal_error( "flex internal error: bad buffer" );


  b->is_our_buffer = 1;

  return b;
}

void Lexer::push_state( int new_state )
{
  if ( start_stack_ptr >= start_stack_depth )
  {
    size_t new_size;

    start_stack_depth += START_STACK_INCR;
    new_size = start_stack_depth * sizeof( int );

    if ( ! start_stack )
      start_stack = (int *) flex_alloc( new_size );

    else
      start_stack = (int *) flex_realloc(
                (void *) start_stack, new_size );

    if ( ! start_stack )
      fatal_error(
      "flex internal error: out of memory expanding start-condition stack" );
  }

  start_stack[start_stack_ptr++] = START();

  BEGIN(new_state);
}

void Lexer::pop_state()
{
  if ( --start_stack_ptr < 0 )
    fatal_error( "flex internal error: start-condition stack underflow" );

  BEGIN(start_stack[start_stack_ptr]);
}

int Lexer::top_state()
{
  return start_stack[start_stack_ptr - 1];
}

void Lexer::fatal_error( const CHAR msg[] )
{
  std::cerr << msg << std::endl;
  throw 1;
}

void *Lexer::flex_alloc( size_t size )
{
  return (void *) malloc( size );
}

void *Lexer::flex_realloc( void *ptr, size_t size )
{
  return (void *) realloc( (UCHAR *) ptr, size );
}

void Lexer::flex_free( void *ptr )
{
  free( ptr );
}

int Lexer::wrap()
{
  return 1;
}

} // namespace loop

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif
