/* GANG Software
 * LAB/loop/Lexer.H
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++


#ifndef loop_Lexer_INCLUDED
#define loop_Lexer_INCLUDED

#include <complex>
#include "base/String.H"
#include "Common.H"

namespace loop {

class Lexer
{

public:
  Lexer();
  virtual ~Lexer();
  typedef char unsigned UCHAR;
  typedef char CHAR;

private:

  protected:
  struct LvalStruct {
    int _exponent;
    base::String _string;
  };

  char const *_input_string;
  size_t _input_length;

protected:

  void _initialize();
  void _deinitialize();

  enum ParserKeys { TOK_end=257, TOK_number=258, TOK_identifier=259, TOK_variable=260, TOK_add=261, TOK_sub=262, TOK_mul=263, TOK_div=264, TOK_pow=265, TOK_Lparen=266, TOK_Rparen=267, TOK_Lbrack=268, TOK_Rbrack=269, TOK_Lbrace=270, TOK_Rbrace=271, TOK_comma=272, TOK_unknown_character=273 };
  
  int lex( LvalStruct &lval );

  void fatal_error( const CHAR msg[] );

private:

  struct BufferState
  {
    BufferState();
    CHAR *ch_buf;
    CHAR *buf_pos;
    size_t buf_size;
    size_t n_chars;
    int is_our_buffer;
    int is_interactive;
    int at_bol;
    int fill_buffer;
    int buffer_status;
  };

  BufferState *current_buffer;
  int leng;
  UCHAR hold_char;
  size_t n_chars;
  CHAR *c_buf_p;
  int init;
  int start;
  int did_buffer_switch_on_eof;
  int last_accepting_state;
  CHAR *last_accepting_cpos;
  int start_stack_ptr;
  int start_stack_depth;
  int *start_stack;

  void *flex_alloc( size_t );
  void *flex_realloc( void *, size_t );
  void flex_free( void * );
  int get_previous_state();
  int try_NUL_trans( int current_state );
  int get_next_buffer();
  void push_state( int new_state );
  void pop_state();
  int top_state();
  void switch_to_buffer( BufferState *new_buffer );
  void load_buffer_state();
  BufferState *create_buffer( int size );
  void delete_buffer( BufferState * b );
  void init_buffer( BufferState * b );
  void flush_buffer( BufferState * b );
  void restart();
  void unput( int c, CHAR *bp );
  void input( CHAR *buf, size_t &result, size_t max_size);
  int input();
  int wrap();
  void less( int, CHAR *bp, CHAR *cp );
  void DO_BEFORE_ACTION( CHAR *bp, CHAR *cp );
  BufferState *scan_buffer( CHAR *base, size_t size );
  BufferState *scan_string( const CHAR *str );
  BufferState *scan_bytes( const CHAR *bytes, int len );

  static const short int accept[];
  static const int ec[];
  static const int meta[];
  static const short int base[];
  static const short int def[];
  static const short int nxt[];
  static const short int chk[];


  static int const BUFFER_NEW;
  static int const BUFFER_NORMAL;
  static int const BUFFER_EOF_PENDING;
  static int const END_OF_BUFFER_CHAR;
  static int const BUF_SIZE;
  static int const EOB_ACT_CONTINUE_SCAN;
  static int const EOB_ACT_END_OF_FILE;
  static int const EOB_ACT_LAST_MATCH;
  static int const READ_BUF_SIZE;
  static int const NUM_RULES;
  static int const END_OF_BUFFER;
  static int const MORE_ADJ;
  static int const INITIAL;
  static int const START_STACK_INCR;
  static int const EXIT_FAILURE_;
  static int const CONSTANT1;
  static int const CONSTANT2;

  inline int BEGIN(int x) { return start = 1 + 2 * x; }
  inline int START() { return (start - 1)/2; }
  inline int STATE_EOF(int state) { return END_OF_BUFFER + state + 1; }
  inline int AT_BOL() { return current_buffer->at_bol; }

  CHAR *text;

  // disabled
  Lexer( Lexer const & );
  Lexer &operator=( Lexer const & );
};

} // namespace loop

#endif // loop_Lexer_INCLUDED

