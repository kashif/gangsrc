/* GANG Software
 * LAB/loop/Parser.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++

#include <stdlib.h>
#include <string.h>
#include <alloca.h>
#include "Parser.H"

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif

#include <string>
#include "eval/Eval.H"
#include "Common.H"

namespace loop {
// constructor
Parser::Parser() : Lexer() {}

// destructor
Parser::~Parser() {}

int Parser::parse( base::ArrayX<EvalLoop::Hash,4> &matrix, base::String const &s )
{
  _initialize();

  _input_string = s.data();
  _input_length = s.length();
  _matrix = &matrix;
  matrix[0].clear();
  matrix[1].clear();
  matrix[2].clear();
  matrix[3].clear();
  int r = parse();
  if (r != 0) { return 1; }
  return r;
}

void
Parser::
error( char const * /*message*/ )
{
//  std::cerr << "Loop parser: " << message << std::endl;
}

Parser::
Parser( Parser const & )
{
  abort();
}

Parser &
Parser::
operator=( Parser const & )
{
  abort();
  return *this;
}

int const Parser::FINAL = 76;
int const Parser::NTBASE = 20;
int const Parser::LAST = 110;
int const Parser::EOF_ = 0;
int const Parser::EMPTY = -2;
int const Parser::FLAG = -32768;
int const Parser::TERROR = 1;
int const Parser::ERRCODE = 256;
int const Parser::INITDEPTH = 200;
size_t const Parser::MAXDEPTH = 10000;

Parser::UCHAR const Parser::translate[] =
{     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     3,     4,     5,     6,
     7,     8,     9,    10,    11,    12,    13,    14,    15,    16,
    17,    18,    19
};

short const Parser::r1[] =
{     0,
    20,    20,    20,    20,    22,    23,    24,    25,    21,    26,
    26,    26,    27,    27,    27,    27,    27,    27,    27,    28,
    28,    29,    29,    29,    30,    30,    30,    30,    31,    31,
    31,    32,    32,    33,    33,    33,    33,    33
};

short const Parser::r2[] =
{     0,
     2,     2,     2,     1,     0,     0,     0,     0,    17,     1,
     3,     3,     1,     1,     2,     2,     3,     3,     2,     1,
     3,     1,     3,     3,     1,     3,     3,     2,     1,     2,
     2,     1,     3,     1,     1,     3,     4,     6
};

short const Parser::defact[] =
{     0,
     0,     4,    34,    35,    20,     0,     0,     0,     0,     0,
     0,    10,    14,    13,    25,    29,    32,     3,     0,     0,
     0,     0,    15,    30,    16,    31,     0,    22,     5,     1,
     2,     0,     0,     0,     0,    19,    28,     0,     0,    21,
     0,     0,    36,     0,     0,     0,    11,    12,    17,    26,
    18,    27,    33,    37,     0,    23,    24,     0,     0,     6,
    38,     0,     0,     0,     0,     7,     0,     0,     8,     0,
     0,     0,     9,     0,     0,     0
};

short const Parser::defgoto[] =
{    74,
    10,    46,    62,    67,    70,    11,    12,    13,    27,    14,
    15,    16,    17
};

short const Parser::pact[] =
{    45,
     7,-32768,-32768,     8,    28,    73,    73,    93,    24,    42,
    67,-32768,-32768,    78,-32768,-32768,    49,-32768,    93,    93,
    93,    93,-32768,-32768,-32768,-32768,    17,    98,-32768,-32768,
-32768,    87,    87,    73,    73,-32768,-32768,    93,     5,-32768,
    93,    93,-32768,    93,    93,    87,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,    93,    98,    98,    47,    -1,-32768,
-32768,    87,    55,    38,    48,-32768,    87,    51,-32768,    87,
    59,    54,-32768,    68,    86,-32768
};

short const Parser::pgoto[] =
{-32768,
-32768,-32768,-32768,-32768,-32768,   -41,    -5,     2,   -17,    -8,
    -3,   -13,-32768
};

short const Parser::table[] =
{    28,
    37,    39,    24,    26,    58,    41,    42,    23,    25,    18,
    28,    41,    42,    61,    37,    36,    40,    24,    26,    54,
    63,    19,    55,    41,    42,    68,    47,    48,    71,    43,
    50,    52,    56,    57,    53,    49,    51,    59,    20,    29,
    50,    52,    37,    37,    30,     1,    28,     2,     3,     4,
     5,     6,     7,    32,    33,    65,     8,    32,    33,    38,
     9,    32,    33,    66,    60,    32,    33,    75,    69,    31,
    73,    64,     0,    32,    33,    72,     3,     4,     5,    21,
    22,     3,     4,     5,     8,    76,    34,    35,     0,     8,
     3,     4,     5,     6,     7,     0,     3,     4,     8,    21,
    22,     3,     4,     0,     8,     0,    44,    45,     0,     8
};

short const Parser::check[] =
{     8,
    14,    19,     6,     7,    46,     7,     8,     6,     7,     3,
    19,     7,     8,    15,    28,    14,    20,    21,    22,    15,
    62,    14,    18,     7,     8,    67,    32,    33,    70,    13,
    34,    35,    41,    42,    38,    34,    35,    55,    11,    16,
    44,    45,    56,    57,     3,     1,    55,     3,     4,     5,
     6,     7,     8,     7,     8,    18,    12,     7,     8,    11,
    16,     7,     8,    16,    18,     7,     8,     0,    18,     3,
    17,    17,    -1,     7,     8,    17,     4,     5,     6,     7,
     8,     4,     5,     6,    12,     0,     9,    10,    -1,    12,
     4,     5,     6,     7,     8,    -1,     4,     5,    12,     7,
     8,     4,     5,    -1,    12,    -1,     9,    10,    -1,    12
};


int
Parser::
parse()
{
  int state;
  int n;
  short *ssp;
  LvalStruct *vsp;
  int errstatus;
  int char1 = 0;

  short ssa[INITDEPTH];
  LvalStruct vsa[INITDEPTH];

  short *ss = ssa;
  LvalStruct *vs = vsa;

  size_t stacksize = INITDEPTH;

  int char_;
  LvalStruct lval;
  int nerrs;

  LvalStruct val;

  int len;

  state = 0;
  errstatus = 0;
  nerrs = 0;
  char_ = EMPTY;

  ssp = ss - 1;
  vsp = vs;

  newstate:

  *++ssp = state;

  if (ssp >= ss + stacksize - 1)
  {
    LvalStruct *vs1 = vs;
    short *ss1 = ss;

    size_t size = ssp - ss + 1;

    if (stacksize >= MAXDEPTH)
    {
      fatal_error("bison internal error: parser stack overflow");
      return 2;
    }
    stacksize *= 2;
    if (stacksize > MAXDEPTH)
      stacksize = MAXDEPTH;
    ss = (short *) alloca ( (unsigned)(stacksize * sizeof (*ssp)) );
    memcpy((UCHAR *)ss, (UCHAR *)ss1, size * sizeof (*ssp));
    vs = (LvalStruct *) alloca ( (unsigned)(stacksize * sizeof (*vsp)) );
    memcpy((UCHAR *)vs, (UCHAR *)vs1, size * sizeof (*vsp));

    ssp = ss + size - 1;
    vsp = vs + size - 1;

    if (ssp >= ss + stacksize - 1)
      return 1;
  }

  goto backup;

  backup:

  n = pact[state];
  if (n == FLAG)
    goto default_;

  if (char_ == EMPTY)
  {
    char_ = lex(lval);
  }

  if (char_ <= 0)
  {
    char1 = 0;
    char_ = EOF_;

  }
  else
  {
    char1 = TRANSLATE(char_);

  }

  n += char1;
  if (n < 0 || n > LAST || check[n] != char1)
    goto default_;

  n = table[n];

  if (n < 0)
  {
    if (n == FLAG)
      goto errlab;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errlab;

  if (n == FINAL)
    return 0;

  if (char_ != EOF_)
    char_ = EMPTY;

  *++vsp = lval;

  if (errstatus) errstatus--;

  state = n;
  goto newstate;

  default_:

  n = defact[state];
  if (n == 0)
    goto errlab;

  reduce:
  len = r2[n];
  if (len > 0)
    val = vsp[1-len];

  switch (n) {
    case 1:

{
    // accept
    return 0;
  ;
    break;}
case 2:

{
    // accept
    return 0;
  ;
    break;}
case 3:

{
    // error
    return 1;
  ;
    break;}
case 4:

{
    // error
    return 1;
  ;
    break;}
case 5:

{ _index = 0; ;
    break;}
case 6:

{ _index = 1; ;
    break;}
case 7:

{ _index = 2; ;
    break;}
case 8:

{ _index = 3; ;
    break;}
case 10:

{
    (*_matrix)[_index][vsp[0]._exponent] = vsp[0]._string;
  ;
    break;}
case 11:

{
    // this is wrong: should add, not overwrite
    base::String s = (*_matrix)[_index][vsp[0]._exponent];
    if (!s.empty()) { s += '+'; }
    s += vsp[0]._string;
    (*_matrix)[_index][vsp[0]._exponent] = s;
  ;
    break;}
case 12:

{
    base::String s = (*_matrix)[_index][vsp[0]._exponent];
    s += "-";
    s += vsp[0]._string;
    (*_matrix)[_index][vsp[0]._exponent] = s;
  ;
    break;}
case 13:

{
    val._string = vsp[0]._string;
    val._exponent = 0;
  ;
    break;}
case 14:

{
    val._string = "1";
    val._exponent = vsp[0]._exponent;
  ;
    break;}
case 15:

{
    val._string = "1";
    val._exponent = vsp[0]._exponent;
  ;
    break;}
case 16:

{
    val._string = "-1";
    val._exponent = vsp[0]._exponent;
  ;
    break;}
case 17:

{
    val._string = vsp[-2]._string;
    val._exponent = vsp[0]._exponent;
  ;
    break;}
case 18:

{
    val._string = vsp[-2]._string;
    val._exponent = -vsp[0]._exponent;
  ;
    break;}
case 19:

{
    val._string = vsp[-1]._string;
    val._exponent = vsp[0]._exponent;
  ;
    break;}
case 20:

{
    val._exponent = 1;
  ;
    break;}
case 21:

{
    eval::evaluate(val._exponent, vsp[0]._string );
  ;
    break;}
case 22:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 23:

{
    val._string = vsp[-2]._string;
    val._string += '+';
    val._string += vsp[0]._string;
  ;
    break;}
case 24:

{
    val._string = vsp[-2]._string;
    val._string += '-';
    val._string += vsp[0]._string;
  ;
    break;}
case 25:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 26:

{
    val._string = vsp[-2]._string;
    val._string += '*';
    val._string += vsp[0]._string;
  ;
    break;}
case 27:

{
    val._string = vsp[-2]._string;
    val._string += '/';
    val._string += vsp[0]._string;
  ;
    break;}
case 28:

{
    val._string = vsp[-1]._string;
    val._string += '*';
    val._string += vsp[0]._string;
  ;
    break;}
case 29:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 30:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 31:

{
    val._string = "-";
    val._string += vsp[0]._string;
  ;
    break;}
case 32:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 33:

{
    val._string = vsp[-2]._string;
    val._string += '^';
    val._string += vsp[0]._string;
  ;
    break;}
case 34:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 35:

{
    val._string = vsp[0]._string;
  ;
    break;}
case 36:

{
    val._string = '(';
    val._string += vsp[-1]._string;
    val._string += ')';
  ;
    break;}
case 37:

{
    val._string = vsp[-3]._string;
    val._string += '[';
    val._string += vsp[-1]._string;
    val._string += ']';
  ;
    break;}
case 38:

{
    val._string = vsp[-5]._string;
    val._string += '[';
    val._string += vsp[-3]._string;
    val._string += ',';
    val._string += vsp[-1]._string;
    val._string += ']';
  ;
    break;}

  }
  vsp -= len;
  ssp -= len;

  *++vsp = val;
  n = r1[n];

  state = pgoto[n - NTBASE] + *ssp;
  if (state >= 0 && state <= LAST && check[state] == *ssp)
    state = table[state];
  else
    state = defgoto[n - NTBASE];

  goto newstate;

  errlab:

  if (! errstatus)
  {
    ++nerrs;
    error("parse error");
  }

  goto errlab1;
  errlab1:

  if (errstatus == 3)
  {
    if (char_ == EOF_)
      return 1;

    char_ = EMPTY;
  }

  errstatus = 3;

  goto errhandle;

  errdefault:

  errpop:

  if (ssp == ss) return 1;
  vsp--;
  state = *--ssp;

  errhandle:

  n = pact[state];
  if (n == FLAG)
    goto errdefault;

  n += TERROR;
  if (n < 0 || n > LAST || check[n] != TERROR)
    goto errdefault;

  n = table[n];
  if (n < 0)
  {
    if (n == FLAG)
      goto errpop;
    n = -n;
    goto reduce;
  }
  else if (n == 0)
    goto errpop;

  if (n == FINAL)
    return 0;

  *++vsp = lval;

  state = n;
  goto newstate;
}

} // namespace loop

#if defined(__sgi) && !defined(__GNUG__)
#pragma reset woff 1110
#endif
