/* GANG Software
 * GEOM/geom/io/OoglWrite.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include "OoglWrite.H"

namespace geom {
namespace io {

OoglWrite::
OoglWrite()
    :
    Writer(),
    _stream((::io::Ostream *)0),
    _geomlist((::geom::surface::SurfaceBase const *)0),
    _milieu((milieu::kernel::MilieuBase const *)0)
{
}

void
OoglWrite::
write(
  ::io::Ostream &o,
  ::geom::surface::SurfaceBase const &g,
  milieu::kernel::MilieuBase const &M ) const
{
  _stream = &o;
  _geomlist = &g;
  _milieu = &M;

  _stream->mode( ::io::CMODE_SCIENTIFIC );

  write_header();

  std::list<surface0::GeomObject *>::const_iterator i;
  for ( i = g.list().begin(); i != g.list().end(); i++ )
  {
    write_part( *i );

    std::list<surface0::GeomObject *>::const_iterator j = i;
    j++;
    if ( j != g.list().end() )
    {
      o << "\n";
    }
  }

  write_footer();

  _stream = (::io::Ostream *)0;
  _geomlist = (::geom::surface::SurfaceBase const *)0;
  _milieu = (milieu::kernel::MilieuBase const *)0;
}

void
OoglWrite::
write_header() const
{
  *_stream
    << "# " << _geomlist->name() << "\n"
    << "# Generated by GANGLab Software v" << base::system->version() << "\n"
    << "# " << datestamp_utc() << "\n\n";
}

void
OoglWrite::
write_footer() const
{
}

void
OoglWrite::
write_part( surface0::GeomObject const *g ) const
{
  if ( g->dimension() == 2U )
  {
    surface0::Surface const *s =
      static_cast<surface0::Surface const *>(g);

    _write_normal0 = _write_normal == 1 ? true : false;
    _write_color0 = _write_color == 1 ? true : false;
    _write_color0 &= s->has_array_color();

    s->compute_normal();

    if ( s->type() == surface0::Surface::INDEXED )
    {
      write_part_indexed( s );
    }
    else if ( s->type() == surface0::Surface::GRID )
    {
      write_part_grid( s );
    }
    else
    {
      DIE();
    }
  }
}

void
OoglWrite::
write_part_indexed(
  surface0::Surface const *g ) const
{
  DIE_IF( g->type() != g->INDEXED );

  uint vertex_count = (uint)g->vertex_count();
  uint face_count = (uint)g->face_count();
  uint edge_count = (uint)0;

  uint dim =
    ( g->spaceform().space == ::geom::SpaceForm::SPACEFORM_R ?
      g->spaceform().dim : g->spaceform().dim + 1 );

  uint i;

  // write header
  if ( _write_color0 ) { *_stream << "C"; };
  if ( _write_normal0 ) { *_stream << "N"; };

  if ( dim == 3U )
  { *_stream << "OFF\n"; }
  else if ( dim == 4U )
  { *_stream << "4OFF\n"; }
  else
  { *_stream << "nOFF " << dim << "\n"; }

  *_stream << vertex_count << " "
    << face_count << " "
    << edge_count << "\n";

  // write vertices
  for( i = 0; i < vertex_count; i++ )
  {
    write_element(g, i);
  }

  // write faces
  for( i = 0; i < g->face_count(); i++ )
  {
    uint n = g->face_count(i);
    *_stream << n;
    uint k;
    for ( k = 0; k < n; k++ )
    {
      *_stream << " " << g->face_vertex(i, k);
    }

#if 0
    // write face color
    if ( _write_color0 )
    {
      base::Color4 const &c = g->face_color(i);
      uint k;
      for ( k = 0; k < 4; k++ )
      {
        *_stream << " " << c[k];
      }
    }
#endif
    *_stream << "\n";
  }
}

void
OoglWrite::
write_part_grid(
  surface0::Surface const *g ) const
{
  DIE_IF( g->type() != g->GRID );

  uint dim =
    ( g->spaceform().space == ::geom::SpaceForm::SPACEFORM_R ?
      g->spaceform().dim : g->spaceform().dim + 1 );

  if ( _write_color0 ) { *_stream << "C"; };
  if ( _write_normal0 ) { *_stream << "N"; };
  if ( dim == 3U )
  { *_stream << "MESH\n"; }
  else if ( dim == 4U )
  { *_stream << "4MESH\n"; }
  else
  { *_stream << "nMESH " << dim << "\n"; }

  *_stream << g->j_step() << " " << g->i_step() << "\n\n";

  math::Vector<Real> v;
  v.allocate( dim );

  uint i;
  for ( i = 0; i < g->vertex_count(); i++ )
  {
    write_element(g, i);

    if ( i % g->j_step() == g->j_step()-1 && i != g->vertex_count()-1)
    {
      *_stream << "\n";
    }
  }
}

void
OoglWrite::
write_element(
  surface0::Surface const *g,
  uint i ) const
{

  uint dim =
    ( g->spaceform().space == ::geom::SpaceForm::SPACEFORM_R ?
      g->spaceform().dim : g->spaceform().dim + 1 );

  // write vertex
  math::Vector<Real> v;
  v.allocate( dim );

  g->vertex( v, i );
  uint k;
  for ( k = 0; k < dim; k++ )
  {
    *_stream << v[k];
    if ( k+1 != dim ) { *_stream << " "; }
  }
  *_stream << "\n";

  // write normal
  if ( _write_normal0 )
  {
    geom::Normal3 const &n = g->vertex_normal(i);
    *_stream << "  ";
    uint k;
    for ( k = 0; k < 3; k++ )
    {
      *_stream << n[i];
      if ( k != 3 - 1 ) { *_stream << " "; }
    }
    *_stream << "\n";
  }

  // write vertex color
  if ( _write_color0 )
  {
    base::Color4 const &c = g->vertex_color(i);
    *_stream << "  ";
    for ( k = 0; k < 4; k++ )
    {
      *_stream << c[k];
      if ( k != 4 - 1 ) { *_stream << " "; }
    }
    *_stream << "\n";
  }

}

} // namespace io
} // namespace geom
