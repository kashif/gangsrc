/* GANG Software
 * GEOM/geom/io/VrmlWrite.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */

#include "VrmlWrite.H"

namespace geom {
namespace io {

VrmlWrite::
VrmlWrite()
    :
    Writer(),
    _stream((::io::Ostream *)0),
    _geomlist((::geom::surface::SurfaceBase const *)0),
    _milieu((milieu::kernel::MilieuBase const *)0)
{
}

void
VrmlWrite::
write(
  ::io::Ostream &o,
  ::geom::surface::SurfaceBase const &g,
  milieu::kernel::MilieuBase const &M ) const
{
  _stream = &o;
  _geomlist = &g;
  _milieu = &M;

  _stream->mode( ::io::CMODE_SCIENTIFIC );

  write_header();

  std::list<surface0::GeomObject *>::const_iterator i;
  for ( i = g.list().begin(); i != g.list().end(); i++ )
  {
    if ( (*i)->dimension() == 2U )
    {
      write_part( static_cast<surface0::Surface const *>(*i) );
    }
  }

  write_footer();

  _stream = (::io::Ostream *)0;
  _geomlist = (::geom::surface::SurfaceBase const *)0;
  _milieu = (milieu::kernel::MilieuBase const *)0;
}

void
VrmlWrite::
write_header() const
{
  *_stream << "#VRML V2.0 utf8\n";

  *_stream << "\n# " << _geomlist->name() << "\n"
    << "# Generated by GANGLab Software v" << base::system->version() << "\n"
    << "# " << datestamp_utc() << "\n\n";
}

void
VrmlWrite::
write_footer() const
{
}

void
VrmlWrite::
write_part(
  surface0::GeomObject const *g ) const
{
  if ( g->dimension() == 2U )
  {
    write_part( static_cast<surface0::Surface const *>(g) );
  }
}

void
VrmlWrite::
write_part(
  surface0::Surface const *g ) const
{
  _write_normal0 = _write_normal == 1 ? true : false;
  _write_color0 = _write_color == 1 ? true : false;
  _write_color0 &= g->has_array_color();

  g->compute_normal();

  *_stream << "Shape {\n";
  *_stream << "  geometry IndexedFaceSet {\n"
    << "    solid FALSE\n"
//  << "    creaseAngle " << creaseAngle << "\n"
    << "    coord Coordinate {\n"
    << "      point [\n";

  // write verticesx
  uint m = g->vertex_count();
  uint i;
  geom::Vertex3 v;
  for ( i = 0; i < m; i++ )
  {
    g->vertex( v, i );
    *_stream << v[0] << " "
      << v[1] << " "
      << v[2] << "\n";
  }

  *_stream << "      ]\n"
    << "    }\n"
    << "    coordIndex [\n";

  // write faces
  m = g->face_count();
  for ( i = 0; i < m; i++ )
  {
    uint n = g->face_count(i);
    uint j;
    for ( j = 0; j < n; j++ )
    {
      *_stream << g->face_vertex(i,j) << " ";
    }
    *_stream << "-1\n";
  }
  *_stream << "    ]\n";

  // write colors
  if ( _write_color0 )
  {
    *_stream << "    color Color {\n      color [\n";
    m = g->vertex_count();
    for ( i = 0; i < m; i++ )
    {
      *_stream << g->vertex_color(i)[0] << " "
        << g->vertex_color(i)[1] << " "
        << g->vertex_color(i)[2] << "\n";
    }
    *_stream << "      ]\n    }\n";
  }

  // write normals
  if ( _write_normal0 )
  {
    *_stream << "    normal Normal {\n      vector [\n";
    m = g->vertex_count();
    for ( i = 0; i < m; i++ )
    {
      *_stream << g->vertex_normal(i)[0] << " "
        << g->vertex_normal(i)[1] << " "
        << g->vertex_normal(i)[2] << "\n";
    }
    *_stream << "      ]\n    }\n";
  }

  *_stream << "  }\n";
  *_stream << "}\n";

  // write normals
}

} // namespace io
} // namespace geom
