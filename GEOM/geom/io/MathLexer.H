/* GANG Software
 * GEOM/geom/io/MathLexer.H
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++


#ifndef geom_io_MathLexer_INCLUDED
#define geom_io_MathLexer_INCLUDED

#include "base/System.H"
#include "io/Istream.H"

namespace geom {
namespace io {
#define TRACEX
/* #define TRACEX cerr << "text=[" << text << "]\n"; */

class MathLexer
{

public:
  MathLexer();
  virtual ~MathLexer();
  typedef char unsigned UCHAR;
  typedef char CHAR;

private:

  protected:

  virtual void error( char const *message ) = 0;
  virtual void cleanup() = 0;

  enum Token
  {
    R_Graphics = 1,
    R_Graphics3D,
    R_SurfaceGraphics,
    R_Real,
    R_Polygon,
    R_leftBrace,
    R_rightBrace,
    R_leftBracket,
    R_rightBracket,
    R_comma
  };

  typedef double Real;

  struct LvalStruct {
    char const *text;
  };

  ::io::Istream *_stream;

  uint _lineno;

private:

protected:

  void _initialize();
  void _deinitialize();

  
  
  int lex( LvalStruct &lval );

  void fatal_error( const CHAR msg[] );

private:

  struct BufferState
  {
    BufferState();
    CHAR *ch_buf;
    CHAR *buf_pos;
    size_t buf_size;
    size_t n_chars;
    int is_our_buffer;
    int is_interactive;
    int at_bol;
    int fill_buffer;
    int buffer_status;
  };

  BufferState *current_buffer;
  int leng;
  UCHAR hold_char;
  size_t n_chars;
  CHAR *c_buf_p;
  int init;
  int start;
  int did_buffer_switch_on_eof;
  int last_accepting_state;
  CHAR *last_accepting_cpos;
  int start_stack_ptr;
  int start_stack_depth;
  int *start_stack;

  void *flex_alloc( size_t );
  void *flex_realloc( void *, size_t );
  void flex_free( void * );
  int get_previous_state();
  int try_NUL_trans( int current_state );
  int get_next_buffer();
  void push_state( int new_state );
  void pop_state();
  int top_state();
  void switch_to_buffer( BufferState *new_buffer );
  void load_buffer_state();
  BufferState *create_buffer( int size );
  void delete_buffer( BufferState * b );
  void init_buffer( BufferState * b );
  void flush_buffer( BufferState * b );
  void restart();
  void unput( int c, CHAR *bp );
  void input( CHAR *buf, size_t &result, size_t max_size);
  int input();
  int wrap();
  void less( int, CHAR *bp, CHAR *cp );
  void DO_BEFORE_ACTION( CHAR *bp, CHAR *cp );
  BufferState *scan_buffer( CHAR *base, size_t size );
  BufferState *scan_string( const CHAR *str );
  BufferState *scan_bytes( const CHAR *bytes, int len );

  static const short int accept[];
  static const int ec[];
  static const int meta[];
  static const short int base[];
  static const short int def[];
  static const short int nxt[];
  static const short int chk[];


  static int const BUFFER_NEW;
  static int const BUFFER_NORMAL;
  static int const BUFFER_EOF_PENDING;
  static int const END_OF_BUFFER_CHAR;
  static int const BUF_SIZE;
  static int const EOB_ACT_CONTINUE_SCAN;
  static int const EOB_ACT_END_OF_FILE;
  static int const EOB_ACT_LAST_MATCH;
  static int const READ_BUF_SIZE;
  static int const NUM_RULES;
  static int const END_OF_BUFFER;
  static int const MORE_ADJ;
  static int const INITIAL;
  static int const START_STACK_INCR;
  static int const EXIT_FAILURE_;
  static int const CONSTANT1;
  static int const CONSTANT2;

  inline int BEGIN(int x) { return start = 1 + 2 * x; }
  inline int START() { return (start - 1)/2; }
  inline int STATE_EOF(int state) { return END_OF_BUFFER + state + 1; }
  inline int AT_BOL() { return current_buffer->at_bol; }

  CHAR *text;

  // disabled
  MathLexer( MathLexer const & );
  MathLexer &operator=( MathLexer const & );
};

} // namespace io
} // namespace geom

#endif // geom_io_MathLexer_INCLUDED

