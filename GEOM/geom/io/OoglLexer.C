/* GANG Software
 * GEOM/geom/io/OoglLexer.C
 * Copyright (C) 2002 Nicholas Schmitt <nick@gang.umass.edu>
 * Wed Sep 18 16:39:46 2002
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the
 * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 * Boston, MA 02111-1307, USA.
 */
// Generated by parse++

#include <stdlib.h>
#include "OoglLexer.H"

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif

#include <iostream>

namespace geom {
namespace io {

// constructor
OoglLexer::
OoglLexer()
{
  _initialize();

  _expectToken = P_KEYWORD;
  _lineno = 1;
}

// destructor
OoglLexer::~OoglLexer() {
  _deinitialize();
}

void OoglLexer::
input( CHAR *buf, size_t &result, size_t max_size )
{
  result = _stream->read( buf, max_size );
}

OoglLexer::OoglLexer( OoglLexer const & )
{
  abort();
}

OoglLexer &OoglLexer::operator=( const OoglLexer & )
{
  abort();
  return *this;
}

int const OoglLexer::BUFFER_NEW = 0;
int const OoglLexer::BUFFER_NORMAL = 1;
int const OoglLexer::BUFFER_EOF_PENDING = 2;
int const OoglLexer::END_OF_BUFFER_CHAR = 0;
int const OoglLexer::BUF_SIZE = 16384;
int const OoglLexer::EOB_ACT_CONTINUE_SCAN = 0;
int const OoglLexer::EOB_ACT_END_OF_FILE = 1;
int const OoglLexer::EOB_ACT_LAST_MATCH = 2;
int const OoglLexer::READ_BUF_SIZE = 8192;
int const OoglLexer::NUM_RULES = 11;
int const OoglLexer::END_OF_BUFFER = 12;
int const OoglLexer::MORE_ADJ = 0;
int const OoglLexer::INITIAL = 0;
int const OoglLexer::START_STACK_INCR = 25;
int const OoglLexer::EXIT_FAILURE_ = 1;
int const OoglLexer::CONSTANT1 = 58;
int const OoglLexer::CONSTANT2 = 114;

void OoglLexer::_initialize()
{
  current_buffer = (BufferState *)0;
  leng = 0;
  hold_char = 0;
  n_chars = 0;
  c_buf_p = (CHAR *)0;
  init = 1;
  start = 0;
  did_buffer_switch_on_eof = 0;
  last_accepting_state = 0;
  last_accepting_cpos = (CHAR *)0;
  start_stack_ptr = 0;
  start_stack_depth = 0;
  start_stack = (int *)0;
}

void OoglLexer::_deinitialize()
{
  if (current_buffer != (BufferState *)0)
  {
    delete_buffer(current_buffer);
  }
}

OoglLexer::BufferState::BufferState()
{
  ch_buf = (CHAR *)0;
  buf_pos = (CHAR *)0;
  buf_size = 0;
  n_chars = 0;
  is_our_buffer = 0;
  is_interactive = 0;
  at_bol = 0;
  fill_buffer = 0;
  buffer_status = 0;
}


const short int OoglLexer::accept[58] =
{   0,
    0,    0,    0,    0,    0,    0,    0,    0,   12,   10,
    8,    7,    8,    9,    8,    8,    9,    9,    9,    9,
    9,    9,   10,   10,    5,   10,    6,    8,    8,    8,
    8,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    5,    5,    5,    0,    6,    0,    1,    0,    0,
    0,    5,    3,    0,    2,    4,    0
};


const int OoglLexer::ec[256] =
{   0,
    1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
    2,    2,    2,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    1,    1,    4,    1,    1,    1,    1,    1,
    1,    1,    5,    1,    6,    7,    1,    8,    8,    8,
    8,    9,    8,    8,    8,    8,    8,    1,    1,    1,
    1,    1,    1,    1,    1,    1,   10,    1,   11,   12,
    1,   13,    1,    1,    1,    1,   14,   15,   16,    1,
    1,    1,   17,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
   18,    1,    1,    1,    1,    1,    1,    1,    1,   19,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1
};


const int OoglLexer::meta[20] =
{   0,
    1,    1,    2,    1,    1,    1,    3,    3,    3,    1,
    1,    1,    1,    1,    1,    1,    1,    1,    1
};


const short int OoglLexer::base[61] =
{   0,
    0,    3,    7,    0,   25,    0,   30,    0,  113,  114,
   38,  114,  108,  114,   39,  107,   30,   38,   99,   94,
   96,   34,  100,   47,   51,   55,   57,   47,  102,  101,
  100,   92,   90,   54,    0,   57,   84,   88,   87,   77,
   66,    0,   68,   72,   82,   74,   65,  114,   55,   55,
   76,   84,  114,   48,  114,  114,  114,   93,   96,   42
};


const short int OoglLexer::def[61] =
{   0,
   58,   58,   57,    3,   58,    5,    5,    7,   57,   57,
   57,   57,   59,   57,   57,   59,   57,   57,   57,   18,
   57,   57,   60,   57,   57,   57,   57,   57,   59,   59,
   59,   57,   57,   57,   20,   57,   57,   57,   57,   57,
   57,   25,   57,   57,   57,   57,   57,   57,   57,   57,
   57,   57,   57,   57,   57,   57,    0,   57,   57,   57
};


const short int OoglLexer::nxt[134] =
{   0,
   57,   11,   12,   13,   11,   12,   13,   14,   15,   12,
   16,   14,   14,   14,   14,   17,   18,   14,   14,   14,
   19,   20,   21,   14,   14,   22,   11,   12,   13,   23,
   23,   24,   25,   25,   26,   10,   10,   27,   27,   28,
   28,   29,   29,   32,   42,   33,   34,   39,   28,   40,
   29,   32,   35,   33,   43,   43,   36,   44,   42,   42,
   56,   45,   46,   46,   46,   46,   55,   32,   45,   33,
   39,   54,   40,   43,   43,   43,   43,   53,   45,   43,
   43,   46,   46,   52,   52,   45,   51,   51,   50,   52,
   52,   52,   52,   10,   10,   10,   30,   49,   30,   48,
   47,   38,   37,   31,   31,   31,   41,   38,   57,   37,
   31,   31,   57,    9,   57,   57,   57,   57,   57,   57,
   57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
   57,   57,   57
};


const short int OoglLexer::chk[134] =
{   0,
    0,    1,    1,    1,    2,    2,    2,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
    3,    3,    3,    3,    3,    3,    5,    5,    5,    5,
    5,    5,    5,    5,    7,    7,    7,    7,    7,   11,
   15,   11,   15,   17,   60,   17,   18,   22,   28,   22,
   28,   18,   18,   18,   24,   24,   18,   25,   25,   25,
   54,   25,   26,   26,   27,   27,   50,   34,   25,   34,
   36,   49,   36,   41,   41,   43,   43,   47,   43,   44,
   44,   46,   46,   51,   51,   43,   45,   45,   40,   45,
   45,   52,   52,   58,   58,   58,   59,   39,   59,   38,
   37,   33,   32,   31,   30,   29,   23,   21,   20,   19,
   16,   13,    9,   57,   57,   57,   57,   57,   57,   57,
   57,   57,   57,   57,   57,   57,   57,   57,   57,   57,
   57,   57,   57
};



int OoglLexer::input()
{
  int c;

  *c_buf_p = hold_char;

  if ( *c_buf_p == END_OF_BUFFER_CHAR )
  {
    if ( c_buf_p < &current_buffer->ch_buf[n_chars] )
      *c_buf_p = '\0';
    else
    {
      int offset = (int)(c_buf_p - text);
      ++c_buf_p;

      switch ( get_next_buffer() )
      {
      case EOB_ACT_LAST_MATCH:
        restart();
      case EOB_ACT_END_OF_FILE:
      {
        if ( wrap() )
          return EOF;

        if ( ! did_buffer_switch_on_eof )
          restart();
        return input();
      }

      case EOB_ACT_CONTINUE_SCAN:
        c_buf_p = text + offset;
        break;
      }
    }
  }

  c = *(unsigned char *) c_buf_p;
  *c_buf_p = '\0';
  hold_char = *++c_buf_p;

  return c;
}


void OoglLexer::less( int n, CHAR *bp, CHAR *cp )
{
  for (;;)
  {
    *cp = hold_char;
    c_buf_p = cp = bp + n - MORE_ADJ;
    DO_BEFORE_ACTION( bp, cp );
  }
}

void OoglLexer::DO_BEFORE_ACTION( CHAR *bp, CHAR *cp )
{
  text = bp;
  leng = (int) (cp - bp);
  hold_char = *cp;
  *cp = '\0';
  c_buf_p = cp;
}

int OoglLexer::lex( LvalStruct &lval )
{
  int current_state;
  CHAR *cp = (char *)0;
  CHAR *bp = (char *)0;
  int act;




  switch (_expectToken) {
    case P_KEYWORD: BEGIN(L_KEYWORD); break;
    case P_REAL: BEGIN(L_Real); break;
    case P_UINT: BEGIN(L_UINT); break;
  }




  if ( init )
  {
    init = 0;

    if ( ! start )
      start = 1;

    if ( ! current_buffer )
      current_buffer =
        create_buffer( BUF_SIZE );

    load_buffer_state();
  }

  for(;;)
  {
    cp = c_buf_p;


    *cp = hold_char;


    bp = cp;

    current_state = start;
match:
    do
    {
      UCHAR c = ec[(int unsigned)(UCHAR)*cp];
      if ( accept[current_state] )
        {
        last_accepting_state = current_state;
        last_accepting_cpos = cp;
        }
      while ( chk[base[current_state] + c] != current_state )
        {
        current_state = (int) def[current_state];
        if ( current_state >= CONSTANT1 )
                c = meta[(unsigned int) c];
        }
      current_state = nxt[base[current_state] + (unsigned int) c];
      ++cp;
    }
    while ( base[current_state] != CONSTANT2 );

find_action:
    act = accept[current_state];
    if ( act == 0 )
    {
      cp = last_accepting_cpos;
      current_state = last_accepting_state;
      act = accept[current_state];
    }

    text = bp;
    leng = (int) (cp - bp);
    hold_char = *cp;
    *cp = '\0';
    c_buf_p = cp;

do_action:

    switch ( act )
{
      case 0:

      *cp = hold_char;
      cp = last_accepting_cpos;
      current_state = last_accepting_state;
      goto find_action;

case 1:

{
TRACEX;
  lval.text = text;
  return R_OFF;
}
  break;
case 2:

{
TRACEX;
  lval.text = text;
  return R_nOFF;
}
  break;
case 3:

{
TRACEX;
  lval.text = text;
  return R_GRID;
}
  break;
case 4:

{
TRACEX;
  lval.text = text;
  return R_nGRID;
}
  break;
case 5:

{
TRACEX;
  lval.text = text;
  return R_Real;
}
  break;
case 6:

{
TRACEX;
  lval.text = text;
  return R_UINT;
}
  break;
case 7:

{
TRACEX;
  _lineno++;
}
  break;
case 8:

{
TRACEX;
}
  break;
case 9:

{
TRACEX;
}
  break;
case 10:

{
TRACEX;
  cleanup();
  throw ::io::ReadException(
	::io::ReadException::PARSE_ERROR,
	_stream->filename(), _lineno, "unknown text" );
}
  break;
case 11:
;
  break;

case (END_OF_BUFFER + INITIAL + 1):
case (END_OF_BUFFER + L_KEYWORD + 1):
case (END_OF_BUFFER + L_Real + 1):
case (END_OF_BUFFER + L_UINT + 1):
	return 0;

  case END_OF_BUFFER:
  {

    int amount_of_matched_text = (int) (cp - text) - 1;

    *cp = hold_char;

    if ( current_buffer->buffer_status == BUFFER_NEW )
    {

      n_chars = current_buffer->n_chars;
      current_buffer->buffer_status = BUFFER_NORMAL;
    }


    if ( c_buf_p <= &current_buffer->ch_buf[n_chars] )
    {
      int next_state;

      c_buf_p = text + amount_of_matched_text;

      current_state = get_previous_state();



      next_state = try_NUL_trans( current_state );

      bp = text + MORE_ADJ;

      if ( next_state )
        {

        cp = ++c_buf_p;
        current_state = next_state;
        goto match;
        }

      else
        {
        cp = c_buf_p;
        goto find_action;
        }
    }

    else switch ( get_next_buffer() )
    {
      case EOB_ACT_END_OF_FILE:
        {
        did_buffer_switch_on_eof = 0;

        if ( wrap() )
                {

                c_buf_p = text + MORE_ADJ;

                act = STATE_EOF(START());
                goto do_action;
                }

        else
                {
                if ( ! did_buffer_switch_on_eof )
                        restart();
                }
        break;
        }

      case EOB_ACT_CONTINUE_SCAN:
        c_buf_p =
                text + amount_of_matched_text;

        current_state = get_previous_state();

        cp = c_buf_p;
        bp = text + MORE_ADJ;
        goto match;

      case EOB_ACT_LAST_MATCH:
        c_buf_p =
        &current_buffer->ch_buf[n_chars];

        current_state = get_previous_state();

        cp = c_buf_p;
        bp = text + MORE_ADJ;
        goto find_action;
    }
    break;
  }

  default:
    fatal_error(
      "flex internal error: no action found" );
}
  }
}

int OoglLexer::get_next_buffer()
{
  CHAR *dest = current_buffer->ch_buf;
  CHAR *source = text;
  int number_to_move, i;
  int ret_val;

  if ( c_buf_p > &current_buffer->ch_buf[n_chars + 1] )
    fatal_error(
    "flex internal error: end of buffer missed" );

  if ( current_buffer->fill_buffer == 0 )
  {
    if ( c_buf_p - text - MORE_ADJ == 1 )
    {

      return EOB_ACT_END_OF_FILE;
    }

    else
    {

      return EOB_ACT_LAST_MATCH;
    }
  }

  number_to_move = (int) (c_buf_p - text) - 1;

  for ( i = 0; i < number_to_move; ++i )
    *(dest++) = *(source++);

  if ( current_buffer->buffer_status == BUFFER_EOF_PENDING )

    current_buffer->n_chars = n_chars = 0;

  else
  {
    int num_to_read =
      (int)(current_buffer->buf_size - number_to_move - 1);

    while ( num_to_read <= 0 )
    {
      BufferState * b = current_buffer;

      int c_buf_p_offset =
        (int) (c_buf_p - b->ch_buf);

      if ( b->is_our_buffer )
        {
        int new_size = (int)(b->buf_size * 2);

        if ( new_size <= 0 )
                b->buf_size += b->buf_size / 8;
        else
                b->buf_size *= 2;

        b->ch_buf = (CHAR *)
                flex_realloc( (void *) b->ch_buf,
                                 b->buf_size + 2 );
        }
      else

        b->ch_buf = 0;

      if ( ! b->ch_buf )
        fatal_error(
        "flex internal error: scanner input buffer overflow" );

      c_buf_p = &b->ch_buf[c_buf_p_offset];

      num_to_read = (int)(current_buffer->buf_size -
                        number_to_move - 1);
    }

    if ( num_to_read > READ_BUF_SIZE )
      num_to_read = READ_BUF_SIZE;


    input( (&current_buffer->ch_buf[number_to_move]),
      n_chars, num_to_read );

    current_buffer->n_chars = n_chars;
  }

  if ( n_chars == 0 )
  {
    if ( number_to_move == MORE_ADJ )
    {
      ret_val = EOB_ACT_END_OF_FILE;
      restart();
    }

    else
    {
      ret_val = EOB_ACT_LAST_MATCH;
      current_buffer->buffer_status =
        BUFFER_EOF_PENDING;
    }
  }

  else
    ret_val = EOB_ACT_CONTINUE_SCAN;

  n_chars += number_to_move;
  current_buffer->ch_buf[n_chars] = END_OF_BUFFER_CHAR;
  current_buffer->ch_buf[n_chars + 1] = END_OF_BUFFER_CHAR;

  text = &current_buffer->ch_buf[0];

  return ret_val;
}

int OoglLexer::get_previous_state()
{
  int current_state;
  CHAR *cp;

  current_state = start;

  for ( cp = text + MORE_ADJ; cp < c_buf_p; ++cp )
  {
    UCHAR c = (*cp ? ec[(int unsigned)(UCHAR)*cp] : 1);
    if ( accept[current_state] )
    {
      last_accepting_state = current_state;
      last_accepting_cpos = cp;
    }
    while ( chk[base[current_state] + c] != current_state )
    {
      current_state = (int) def[current_state];
      if ( current_state >= CONSTANT1 )
        c = meta[(unsigned int) c];
    }
    current_state = nxt[base[current_state] + (unsigned int) c];
  }

  return current_state;
}

int OoglLexer::try_NUL_trans( int current_state )
{
  int is_jam;
  CHAR *cp = c_buf_p;

  UCHAR c = 1;
  if ( accept[current_state] )
  {
    last_accepting_state = current_state;
    last_accepting_cpos = cp;
  }
  while ( chk[base[current_state] + c] != current_state )
  {
    current_state = (int) def[current_state];
    if ( current_state >= CONSTANT1 )
      c = meta[(unsigned int) c];
  }
  current_state = nxt[base[current_state] + (unsigned int) c];
  is_jam = ( current_state == CONSTANT1 - 1 );

  return is_jam ? 0 : current_state;
}

void OoglLexer::unput( int c, CHAR *bp )
{
  CHAR *cp = c_buf_p;

  *cp = hold_char;

  if ( cp < current_buffer->ch_buf + 2 )
  {

    size_t number_to_move = n_chars + 2;
    CHAR *dest = &current_buffer->ch_buf[
                current_buffer->buf_size + 2];
    CHAR *source =
        &current_buffer->ch_buf[number_to_move];

    while ( source > current_buffer->ch_buf )
      *--dest = *--source;

    cp += (int) (dest - source);
    bp += (int) (dest - source);
    current_buffer->n_chars =
      n_chars = current_buffer->buf_size;

    if ( cp < current_buffer->ch_buf + 2 )
      fatal_error( "flex internal error: push-back overflow" );
  }

  *--cp = (CHAR) c;

  text = bp;
  hold_char = *cp;
  c_buf_p = cp;
}

void OoglLexer::restart()
{
  if ( ! current_buffer )
    current_buffer = create_buffer( BUF_SIZE );

  init_buffer( current_buffer );
  load_buffer_state();
}

void OoglLexer::switch_to_buffer( BufferState * new_buffer )
{
  if ( current_buffer == new_buffer )
    return;

  if ( current_buffer )
  {

    *c_buf_p = hold_char;
    current_buffer->buf_pos = c_buf_p;
    current_buffer->n_chars = n_chars;
  }

  current_buffer = new_buffer;
  load_buffer_state();


  did_buffer_switch_on_eof = 1;
}

void OoglLexer::load_buffer_state()
{
  n_chars = current_buffer->n_chars;
  text = c_buf_p = current_buffer->buf_pos;
  hold_char = *c_buf_p;
}

OoglLexer::BufferState *OoglLexer::create_buffer( int size )
{
  BufferState *b;

  b = (BufferState *) flex_alloc( sizeof( BufferState ) );
  if ( ! b )
    fatal_error( "flex internal error: out of memory" );

  b->buf_size = size;


  b->ch_buf = (CHAR *) flex_alloc( b->buf_size + 2 );
  if ( ! b->ch_buf )
    fatal_error( "flex internal error: out of memory" );

  b->is_our_buffer = 1;

  init_buffer( b );

  return b;
}

void OoglLexer::delete_buffer( BufferState * b )
{
  if ( ! b )
    return;

  if ( b == current_buffer )
  {
    current_buffer = (BufferState *)0;
  }

  if ( b->is_our_buffer )
  {
    flex_free( (void *) b->ch_buf );
  }

  flex_free( (void *) b );
}

void OoglLexer::init_buffer( BufferState * b )
{
  flush_buffer( b );

  b->fill_buffer = 1;
  b->is_interactive = 0;
}

void OoglLexer::flush_buffer( BufferState * b )
{
  if ( ! b )
    return;

  b->n_chars = 0;

  b->ch_buf[0] = END_OF_BUFFER_CHAR;
  b->ch_buf[1] = END_OF_BUFFER_CHAR;

  b->buf_pos = &b->ch_buf[0];

  b->at_bol = 1;
  b->buffer_status = BUFFER_NEW;

  if ( b == current_buffer )
    load_buffer_state();
}

OoglLexer::BufferState *OoglLexer::scan_buffer( CHAR *base, size_t size )
{
  BufferState * b;

  if ( size < 2 ||
       base[size-2] != END_OF_BUFFER_CHAR ||
       base[size-1] != END_OF_BUFFER_CHAR )

    return 0;

  b = (BufferState *) flex_alloc( sizeof( BufferState ) );
  if ( ! b )
    fatal_error( "flex internal error: out of memory" );

  b->buf_size = size - 2;
  b->buf_pos = b->ch_buf = base;
  b->is_our_buffer = 0;
  b->n_chars = b->buf_size;
  b->is_interactive = 0;
  b->at_bol = 1;
  b->fill_buffer = 0;
  b->buffer_status = BUFFER_NEW;

  switch_to_buffer( b );

  return b;
}

OoglLexer::BufferState *OoglLexer::scan_string( const CHAR *str )
{
  int len;
  for ( len = 0; str[len]; ++len )
    ;

  return scan_bytes( str, len );
}

OoglLexer::BufferState *OoglLexer::scan_bytes( const CHAR *bytes, int len )
{
  BufferState * b;
  CHAR *buf;
  size_t n;
  int i;


  n = len + 2;
  buf = (CHAR *) flex_alloc( n );
  if ( ! buf )
    fatal_error( "flex internal error: out of memory" );

  for ( i = 0; i < len; ++i )
    buf[i] = bytes[i];

  buf[len] = buf[len+1] = END_OF_BUFFER_CHAR;

  b = scan_buffer( buf, n );
  if ( ! b )
    fatal_error( "flex internal error: bad buffer" );


  b->is_our_buffer = 1;

  return b;
}

void OoglLexer::push_state( int new_state )
{
  if ( start_stack_ptr >= start_stack_depth )
  {
    size_t new_size;

    start_stack_depth += START_STACK_INCR;
    new_size = start_stack_depth * sizeof( int );

    if ( ! start_stack )
      start_stack = (int *) flex_alloc( new_size );

    else
      start_stack = (int *) flex_realloc(
                (void *) start_stack, new_size );

    if ( ! start_stack )
      fatal_error(
      "flex internal error: out of memory expanding start-condition stack" );
  }

  start_stack[start_stack_ptr++] = START();

  BEGIN(new_state);
}

void OoglLexer::pop_state()
{
  if ( --start_stack_ptr < 0 )
    fatal_error( "flex internal error: start-condition stack underflow" );

  BEGIN(start_stack[start_stack_ptr]);
}

int OoglLexer::top_state()
{
  return start_stack[start_stack_ptr - 1];
}

void OoglLexer::fatal_error( const CHAR msg[] )
{
  std::cerr << msg << std::endl;
  throw 1;
}

void *OoglLexer::flex_alloc( size_t size )
{
  return (void *) malloc( size );
}

void *OoglLexer::flex_realloc( void *ptr, size_t size )
{
  return (void *) realloc( (UCHAR *) ptr, size );
}

void OoglLexer::flex_free( void *ptr )
{
  free( ptr );
}

int OoglLexer::wrap()
{
  return 1;
}

} // namespace io
} // namespace geom

#if defined(__sgi) && !defined(__GNUG__)
#pragma set woff 1110
#endif
